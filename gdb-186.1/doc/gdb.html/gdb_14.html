<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from /mnt/apple/gdb/source/gdb.apple/source/gdb/gdb/doc/gdb.texinfo on 23 November 1999 -->

<TITLE>Debugging with GDB - Specifying a Debugging Target</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_13.html">previous</A>, <A HREF="gdb_15.html">next</A>, <A HREF="gdb_21.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC112" HREF="gdb_toc.html#TOC112">Specifying a Debugging Target</A></H1>

<P>
<A NAME="IDX479"></A>
<A NAME="IDX480"></A>

</P>
<P>
A <STRONG>target</STRONG> is the execution environment occupied by your program.
Often, GDB runs in the same host environment as your program; in
that case, the debugging target is specified as a side effect when you
use the <CODE>file</CODE> or <CODE>core</CODE> commands.  When you need more
flexibility--for example, running GDB on a physically separate
host, or controlling a standalone system over a serial port or a
realtime system over a TCP/IP connection--you 

</P>



<H2><A NAME="SEC113" HREF="gdb_toc.html#TOC113">Active targets</A></H2>

<P>
<A NAME="IDX481"></A>
<A NAME="IDX482"></A>
<A NAME="IDX483"></A>

</P>
<P>
There are three classes of targets: processes, core files, and
executable files.  GDB can work concurrently on up to three
active targets, one in each class.  This allows you to (for example)
start a process and inspect its activity without abandoning your work on
a core file.

</P>
<P>
For example, if you execute <SAMP>`gdb a.out'</SAMP>, then the executable file
<CODE>a.out</CODE> is the only active target.  If you designate a core file as
well--presumably from a prior run that crashed and coredumped--then
GDB has two active targets and uses them in tandem, looking
first in the corefile target, then in the executable file, to satisfy
requests for memory addresses.  (Typically, these two classes of target
are complementary, since core files contain only a program's
read-write memory--variables and so on--plus machine status, while
executable files contain only the program text and initialized data.)

</P>
<P>
When you type <CODE>run</CODE>, your executable file becomes an active process
target as well.  When a process target is active, all GDB
commands requesting memory addresses refer to that target; addresses in
an active core file or executable file target are obscured while the
process target is active.

</P>
<P>
Use the <CODE>core-file</CODE> and <CODE>exec-file</CODE> commands to select a new
core file or executable target (see section <A HREF="gdb_13.html#SEC110">Commands to specify files</A>).  To specify as a target a process that is already running, use
the <CODE>attach</CODE> command (see section <A HREF="gdb_5.html#SEC22">Debugging an already-running process</A>).

</P>


<H2><A NAME="SEC114" HREF="gdb_toc.html#TOC114">Commands for managing targets</A></H2>

<DL COMPACT>

<DT><CODE>target <VAR>type</VAR> <VAR>parameters</VAR></CODE>
<DD>
Connects the GDB host environment to a target machine or
process.  A target is typically a protocol for talking to debugging
facilities.  You use the argument <VAR>type</VAR> to specify the type or
protocol of the target machine.

Further <VAR>parameters</VAR> are interpreted by the target protocol, but
typically include things like device names or host names to connect
with, process numbers, and baud rates.

The <CODE>target</CODE> command does not repeat if you press <KBD>RET</KBD> again
after executing the command.

<A NAME="IDX484"></A>
<DT><CODE>help target</CODE>
<DD>
Displays the names of all targets available.  To display targets
currently selected, use either <CODE>info target</CODE> or <CODE>info files</CODE>
(see section <A HREF="gdb_13.html#SEC110">Commands to specify files</A>).

<DT><CODE>help target <VAR>name</VAR></CODE>
<DD>
Describe a particular target, including any parameters necessary to
select it.

<A NAME="IDX485"></A>
<DT><CODE>set gnutarget <VAR>args</VAR></CODE>
<DD>
GDB uses its own library BFD to read your files.  GDB 
knows whether it is reading an <STRONG>executable</STRONG>,
a <STRONG>core</STRONG>, or a <STRONG>.o</STRONG> file; however, you can specify the file format 
with the <CODE>set gnutarget</CODE> command.  Unlike most <CODE>target</CODE> commands, 
with <CODE>gnutarget</CODE> the <CODE>target</CODE> refers to a program, not a machine.

<EM>Warning:</EM> To specify a file format with <CODE>set gnutarget</CODE>,
you must know the actual BFD name.

See section <A HREF="gdb_13.html#SEC110">Commands to specify files</A>.

<A NAME="IDX486"></A>
<DT><CODE>show gnutarget</CODE>
<DD>
Use the <CODE>show gnutarget</CODE> command to display what file format
<CODE>gnutarget</CODE> is set to read.  If you have not set <CODE>gnutarget</CODE>,
GDB will determine the file format for each file automatically,
and <CODE>show gnutarget</CODE> displays <SAMP>`The current BDF target is "auto"'</SAMP>.
</DL>

<P>
Here are some common targets (available, or not, depending on the GDB
configuration):

</P>
<DL COMPACT>

<DT><CODE>target exec <VAR>program</VAR></CODE>
<DD>
<A NAME="IDX487"></A>
 
An executable file.  <SAMP>`target exec <VAR>program</VAR>'</SAMP> is the same as
<SAMP>`exec-file <VAR>program</VAR>'</SAMP>.

<A NAME="IDX488"></A>
<DT><CODE>target core <VAR>filename</VAR></CODE>
<DD>
A core dump file.  <SAMP>`target core <VAR>filename</VAR>'</SAMP> is the same as
<SAMP>`core-file <VAR>filename</VAR>'</SAMP>.

<A NAME="IDX489"></A>
<DT><CODE>target remote <VAR>dev</VAR></CODE>
<DD>
Remote serial target in GDB-specific protocol.  The argument <VAR>dev</VAR>
specifies what serial device to use for the connection (e.g.
<TT>`/dev/ttya'</TT>). See section <A HREF="gdb_14.html#SEC116">Remote debugging</A>.  <CODE>target remote</CODE>
now supports the <CODE>load</CODE> command.  This is only useful if you have
some other way of getting the stub to the target system, and you can put
it somewhere in memory where it won't get clobbered by the download.

<A NAME="IDX490"></A>
<DT><CODE>target sim</CODE>
<DD>
CPU simulator.  See section <A HREF="gdb_14.html#SEC148">Simulated CPU target</A>.
</DL>

<P>
The following targets are all CPU-specific, and only available for
specific configurations.

</P>
<DL COMPACT>

<DT><CODE>target abug <VAR>dev</VAR></CODE>
<DD>
<A NAME="IDX491"></A>
 
ABug ROM monitor for M68K.

<A NAME="IDX492"></A>
<DT><CODE>target adapt <VAR>dev</VAR></CODE>
<DD>
Adapt monitor for A29K.

<A NAME="IDX493"></A>
<DT><CODE>target amd-eb <VAR>dev</VAR> <VAR>speed</VAR> <VAR>PROG</VAR></CODE>
<DD>
<A NAME="IDX494"></A>
Remote PC-resident AMD EB29K board, attached over serial lines.
<VAR>dev</VAR> is the serial device, as for <CODE>target remote</CODE>;
<VAR>speed</VAR> allows you to specify the linespeed; and <VAR>PROG</VAR> is the
name of the program to be debugged, as it appears to DOS on the PC.
See section <A HREF="gdb_14.html#SEC129">The EBMON protocol for AMD29K</A>.

<A NAME="IDX495"></A>
<DT><CODE>target array <VAR>dev</VAR></CODE>
<DD>
Array Tech LSI33K RAID controller board.

<A NAME="IDX496"></A>
<DT><CODE>target bug <VAR>dev</VAR></CODE>
<DD>
BUG monitor, running on a MVME187 (m88k) board.

<A NAME="IDX497"></A>
<DT><CODE>target cpu32bug <VAR>dev</VAR></CODE>
<DD>
CPU32BUG monitor, running on a CPU32 (M68K) board.

<A NAME="IDX498"></A>
<DT><CODE>target dbug <VAR>dev</VAR></CODE>
<DD>
dBUG ROM monitor for Motorola ColdFire.

<A NAME="IDX499"></A>
<DT><CODE>target ddb <VAR>dev</VAR></CODE>
<DD>
NEC's DDB monitor for Mips Vr4300.

<A NAME="IDX500"></A>
<DT><CODE>target dink32 <VAR>dev</VAR></CODE>
<DD>
DINK32 ROM monitor for PowerPC.

<A NAME="IDX501"></A>
<DT><CODE>target e7000 <VAR>dev</VAR></CODE>
<DD>
E7000 emulator for Hitachi H8 and SH.

<A NAME="IDX502"></A>
<DT><CODE>target es1800 <VAR>dev</VAR></CODE>
<DD>
ES-1800 emulator for M68K.

<A NAME="IDX503"></A>
<DT><CODE>target est <VAR>dev</VAR></CODE>
<DD>
EST-300 ICE monitor, running on a CPU32 (M68K) board.

<A NAME="IDX504"></A>
<DT><CODE>target hms <VAR>dev</VAR></CODE>
<DD>
A Hitachi SH, H8/300, or H8/500 board, attached via serial line to your host.
Use special commands <CODE>device</CODE> and <CODE>speed</CODE> to control the serial
line and the communications speed used.
See section <A HREF="gdb_14.html#SEC143">GDB and Hitachi microprocessors</A>.

<A NAME="IDX505"></A>
<DT><CODE>target lsi <VAR>dev</VAR></CODE>
<DD>
LSI ROM monitor for Mips.

<A NAME="IDX506"></A>
<DT><CODE>target m32r <VAR>dev</VAR></CODE>
<DD>
Mitsubishi M32R/D ROM monitor.

<A NAME="IDX507"></A>
<DT><CODE>target mips <VAR>dev</VAR></CODE>
<DD>
IDT/SIM ROM monitor for Mips.

<A NAME="IDX508"></A>
<DT><CODE>target mon960 <VAR>dev</VAR></CODE>
<DD>
MON960 monitor for Intel i960.

<A NAME="IDX509"></A>
<DT><CODE>target nindy <VAR>devicename</VAR></CODE>
<DD>
An Intel 960 board controlled by a Nindy Monitor.  <VAR>devicename</VAR> is
the name of the serial device to use for the connection, e.g.
<TT>`/dev/ttya'</TT>.  See section <A HREF="gdb_14.html#SEC124">GDB with a remote i960 (Nindy)</A>.

<A NAME="IDX510"></A>
<DT><CODE>target nrom <VAR>dev</VAR></CODE>
<DD>
NetROM ROM emulator.  This target only supports downloading.

<A NAME="IDX511"></A>
<DT><CODE>target op50n <VAR>dev</VAR></CODE>
<DD>
OP50N monitor, running on an OKI HPPA board.

<A NAME="IDX512"></A>
<DT><CODE>target pmon <VAR>dev</VAR></CODE>
<DD>
PMON ROM monitor for Mips.

<A NAME="IDX513"></A>
<DT><CODE>target ppcbug <VAR>dev</VAR></CODE>
<DD>
<A NAME="IDX514"></A>
<DT><CODE>target ppcbug1 <VAR>dev</VAR></CODE>
<DD>
PPCBUG ROM monitor for PowerPC.

<A NAME="IDX515"></A>
<DT><CODE>target r3900 <VAR>dev</VAR></CODE>
<DD>
Densan DVE-R3900 ROM monitor for Toshiba R3900 Mips.

<A NAME="IDX516"></A>
<DT><CODE>target rdi <VAR>dev</VAR></CODE>
<DD>
ARM Angel monitor, via RDI library interface.
 
<A NAME="IDX517"></A>
<DT><CODE>target rdp <VAR>dev</VAR></CODE>
<DD>
ARM Demon monitor.

<A NAME="IDX518"></A>
<DT><CODE>target rom68k <VAR>dev</VAR></CODE>
<DD>
ROM 68K monitor, running on an M68K IDP board.

<A NAME="IDX519"></A>
<DT><CODE>target rombug <VAR>dev</VAR></CODE>
<DD>
ROMBUG ROM monitor for OS/9000.

<A NAME="IDX520"></A>
<DT><CODE>target sds <VAR>dev</VAR></CODE>
<DD>
SDS monitor, running on a PowerPC board (such as Motorola's ADS).

<A NAME="IDX521"></A>
<DT><CODE>target sparclite <VAR>dev</VAR></CODE>
<DD>
Fujitsu sparclite boards, used only for the purpose of loading.  
You must use an additional command to debug the program. 
For example: target remote <VAR>dev</VAR> using GDB standard 
remote protocol.

<A NAME="IDX522"></A>
<A NAME="IDX523"></A>
<DT><CODE>target sh3 <VAR>dev</VAR></CODE>
<DD>
<DT><CODE>target sh3e <VAR>dev</VAR></CODE>
<DD>
Hitachi SH-3 and SH-3E target systems.

<A NAME="IDX524"></A>
<DT><CODE>target st2000 <VAR>dev</VAR> <VAR>speed</VAR></CODE>
<DD>
A Tandem ST2000 phone switch, running Tandem's STDBUG protocol.  <VAR>dev</VAR>
is the name of the device attached to the ST2000 serial line;
<VAR>speed</VAR> is the communication line speed.  The arguments are not used
if GDB is configured to connect to the ST2000 using TCP or Telnet.
See section <A HREF="gdb_14.html#SEC133">GDB with a Tandem ST2000</A>.

<A NAME="IDX525"></A>
<DT><CODE>target udi <VAR>keyword</VAR></CODE>
<DD>
Remote AMD29K target, using the AMD UDI protocol.  The <VAR>keyword</VAR>
argument specifies which 29K board or simulator to use.  See section <A HREF="gdb_14.html#SEC128">The UDI protocol for AMD29K</A>.

<A NAME="IDX526"></A>
<DT><CODE>target vxworks <VAR>machinename</VAR></CODE>
<DD>
A VxWorks system, attached via TCP/IP.  The argument <VAR>machinename</VAR>
is the target system's machine name or IP address.
See section <A HREF="gdb_14.html#SEC134">GDB and VxWorks</A>.

<A NAME="IDX527"></A>
<DT><CODE>target w89k <VAR>dev</VAR></CODE>
<DD>
W89K monitor, running on a Winbond HPPA board.

</DL>

<P>
Different targets are available on different configurations of GDB; 
your configuration may have more or fewer targets.

</P>
<P>
Many remote targets require you to download the executable's code
once you've successfully established a connection.

</P>
<DL COMPACT>

<DT><CODE>load <VAR>filename</VAR></CODE>
<DD>
<A NAME="IDX528"></A>
 
Depending on what remote debugging facilities are configured into
GDB, the <CODE>load</CODE> command may be available.  Where it exists, it
is meant to make <VAR>filename</VAR> (an executable) available for debugging
on the remote system--by downloading, or dynamic linking, for example.
<CODE>load</CODE> also records the <VAR>filename</VAR> symbol table in GDB, like
the <CODE>add-symbol-file</CODE> command.

If your GDB does not have a <CODE>load</CODE> command, attempting to
execute it gets the error message "<CODE>You can't do that when your
target is ...</CODE>"

The file is loaded at whatever address is specified in the executable.
For some object file formats, you can specify the load address when you
link the program; for other formats, like a.out, the object file format
specifies a fixed address.

On VxWorks, <CODE>load</CODE> links <VAR>filename</VAR> dynamically on the
current target system as well as adding its symbols in GDB.

<A NAME="IDX529"></A>
With the Nindy interface to an Intel 960 board, <CODE>load</CODE>
downloads <VAR>filename</VAR> to the 960 as well as adding its symbols in
GDB.

<A NAME="IDX530"></A>
<A NAME="IDX531"></A>
<A NAME="IDX532"></A>
<A NAME="IDX533"></A>
When you select remote debugging to a Hitachi SH, H8/300, or H8/500 board
(see section <A HREF="gdb_14.html#SEC143">GDB and Hitachi microprocessors</A>),
the <CODE>load</CODE> command downloads your program to the Hitachi board and also
opens it as the current executable target for GDB on your host
(like the <CODE>file</CODE> command).

<CODE>load</CODE> does not repeat if you press <KBD>RET</KBD> again after using it.
</DL>



<H2><A NAME="SEC115" HREF="gdb_toc.html#TOC115">Choosing target byte order</A></H2>

<P>
<A NAME="IDX534"></A>
<A NAME="IDX535"></A>
<A NAME="IDX536"></A>
<A NAME="IDX537"></A>
<A NAME="IDX538"></A>
<A NAME="IDX539"></A>

</P>
<P>
Some types of processors, such as the MIPS, PowerPC, and Hitachi SH,
offer the ability to run either big-endian or little-endian byte
orders.  Usually the executable or symbol will include a bit to
designate the endian-ness, and you will not need to worry about
which to use.  However, you may still find it useful to adjust
GDB's idea of processor endian-ness manually.

</P>
<DL COMPACT>

<DT><CODE>set endian big</CODE>
<DD>
<A NAME="IDX540"></A>
 
Instruct GDB to assume the target is big-endian.

<A NAME="IDX541"></A>
<DT><CODE>set endian little</CODE>
<DD>
Instruct GDB to assume the target is little-endian.

<A NAME="IDX542"></A>
<DT><CODE>set endian auto</CODE>
<DD>
Instruct GDB to use the byte order associated with the
executable.

<DT><CODE>show endian</CODE>
<DD>
Display GDB's current idea of the target byte order.

</DL>

<P>
Note that these commands merely adjust interpretation of symbolic
data on the host, and that they have absolutely no effect on the
target system.

</P>


<H2><A NAME="SEC116" HREF="gdb_toc.html#TOC116">Remote debugging</A></H2>
<P>
<A NAME="IDX543"></A>

</P>
<P>
If you are trying to debug a program running on a machine that cannot run
GDB in the usual way, it is often useful to use remote debugging.  
For example, you might use remote debugging on an operating system kernel, 
or on a small system which does not have a general purpose operating system
powerful enough to run a full-featured debugger.

</P>
<P>
Some configurations of GDB have special serial or TCP/IP interfaces
to make this work with particular debugging targets.  In addition,
GDB comes with a generic serial protocol (specific to GDB, 
but not specific to any particular target system) which you can use if you
write the remote stubs--the code that runs on the remote system to
communicate with GDB.

</P>
<P>
Other remote targets may be available in your
configuration of GDB; use <CODE>help target</CODE> to list them.

</P>



<H3><A NAME="SEC117" HREF="gdb_toc.html#TOC117">The GDB remote serial protocol</A></H3>

<P>
<A NAME="IDX544"></A>
To debug a program running on another machine (the debugging
<STRONG>target</STRONG> machine), you must first arrange for all the usual
prerequisites for the program to run by itself.  For example, for a C
program, you need:

</P>

<OL>
<LI>

A startup routine to set up the C runtime environment; these usually
have a name like <TT>`crt0'</TT>.  The startup routine may be supplied by
your hardware supplier, or you may have to write your own.

<LI>

You probably need a C subroutine library to support your program's
subroutine calls, notably managing input and output.

<LI>

A way of getting your program to the other machine--for example, a
download program.  These are often supplied by the hardware
manufacturer, but you may have to write your own from hardware
documentation.
</OL>

<P>
The next step is to arrange for your program to use a serial port to
communicate with the machine where GDB is running (the <STRONG>host</STRONG>
machine).  In general terms, the scheme looks like this:

</P>
<DL COMPACT>

<DT><EM>On the host,</EM>
<DD>
GDB already understands how to use this protocol; when everything
else is set up, you can simply use the <SAMP>`target remote'</SAMP> command
(see section <A HREF="gdb_14.html#SEC112">Specifying a Debugging Target</A>).

<DT><EM>On the target,</EM>
<DD>
you must link with your program a few special-purpose subroutines that
implement the GDB remote serial protocol.  The file containing these
subroutines is called  a <STRONG>debugging stub</STRONG>.

On certain remote targets, you can use an auxiliary program
<CODE>gdbserver</CODE> instead of linking a stub into your program.
See section <A HREF="gdb_14.html#SEC122">Using the <CODE>gdbserver</CODE> program</A>, for details.
</DL>

<P>
The debugging stub is specific to the architecture of the remote
machine; for example, use <TT>`sparc-stub.c'</TT> to debug programs on
SPARC boards.

</P>
<P>
<A NAME="IDX545"></A>
These working remote stubs are distributed with GDB:

</P>
<DL COMPACT>

<DT><CODE>i386-stub.c</CODE>
<DD>
<A NAME="IDX546"></A>
<A NAME="IDX547"></A>
<A NAME="IDX548"></A>
For Intel 386 and compatible architectures.

<DT><CODE>m68k-stub.c</CODE>
<DD>
<A NAME="IDX549"></A>
<A NAME="IDX550"></A>
<A NAME="IDX551"></A>
For Motorola 680x0 architectures.

<DT><CODE>sh-stub.c</CODE>
<DD>
<A NAME="IDX552"></A>
<A NAME="IDX553"></A>
<A NAME="IDX554"></A>
For Hitachi SH architectures.

<DT><CODE>sparc-stub.c</CODE>
<DD>
<A NAME="IDX555"></A>
<A NAME="IDX556"></A>
For SPARC architectures.

<DT><CODE>sparcl-stub.c</CODE>
<DD>
<A NAME="IDX557"></A>
<A NAME="IDX558"></A>
<A NAME="IDX559"></A>
For Fujitsu SPARCLITE architectures.

</DL>

<P>
The <TT>`README'</TT> file in the GDB distribution may list other
recently added stubs.

</P>



<H4><A NAME="SEC118" HREF="gdb_toc.html#TOC118">What the stub can do for you</A></H4>

<P>
<A NAME="IDX560"></A>
The debugging stub for your architecture supplies these three
subroutines:

</P>
<DL COMPACT>

<DT><CODE>set_debug_traps</CODE>
<DD>
<A NAME="IDX561"></A>
<A NAME="IDX562"></A>
This routine arranges for <CODE>handle_exception</CODE> to run when your
program stops.  You must call this subroutine explicitly near the
beginning of your program.

<DT><CODE>handle_exception</CODE>
<DD>
<A NAME="IDX563"></A>
<A NAME="IDX564"></A>
This is the central workhorse, but your program never calls it
explicitly--the setup code arranges for <CODE>handle_exception</CODE> to
run when a trap is triggered.

<CODE>handle_exception</CODE> takes control when your program stops during
execution (for example, on a breakpoint), and mediates communications
with GDB on the host machine.  This is where the communications
protocol is implemented; <CODE>handle_exception</CODE> acts as the GDB
representative on the target machine; it begins by sending summary
information on the state of your program, then continues to execute,
retrieving and transmitting any information GDB needs, until you
execute a GDB command that makes your program resume; at that point,
<CODE>handle_exception</CODE> returns control to your own code on the target
machine. 

<DT><CODE>breakpoint</CODE>
<DD>
<A NAME="IDX565"></A>
Use this auxiliary subroutine to make your program contain a
breakpoint.  Depending on the particular situation, this may be the only
way for GDB to get control.  For instance, if your target
machine has some sort of interrupt button, you won't need to call this;
pressing the interrupt button transfers control to
<CODE>handle_exception</CODE>---in effect, to GDB.  On some machines,
simply receiving characters on the serial port may also trigger a trap;
again, in that situation, you don't need to call <CODE>breakpoint</CODE> from
your own program--simply running <SAMP>`target remote'</SAMP> from the host
GDB session gets control.  

Call <CODE>breakpoint</CODE> if none of these is true, or if you simply want
to make certain your program stops at a predetermined point for the
start of your debugging session.
</DL>



<H4><A NAME="SEC119" HREF="gdb_toc.html#TOC119">What you must do for the stub</A></H4>

<P>
<A NAME="IDX566"></A>
The debugging stubs that come with GDB are set up for a particular
chip architecture, but they have no information about the rest of your
debugging target machine.

</P>
<P>
First of all you need to tell the stub how to communicate with the
serial port.

</P>
<DL COMPACT>

<DT><CODE>int getDebugChar()</CODE>
<DD>
<A NAME="IDX567"></A>
Write this subroutine to read a single character from the serial port.
It may be identical to <CODE>getchar</CODE> for your target system; a
different name is used to allow you to distinguish the two if you wish.

<DT><CODE>void putDebugChar(int)</CODE>
<DD>
<A NAME="IDX568"></A>
Write this subroutine to write a single character to the serial port.
It may be identical to <CODE>putchar</CODE> for your target system; a 
different name is used to allow you to distinguish the two if you wish.
</DL>

<P>
<A NAME="IDX569"></A>
<A NAME="IDX570"></A>
If you want GDB to be able to stop your program while it is
running, you need to use an interrupt-driven serial driver, and arrange
for it to stop when it receives a <CODE>^C</CODE> (<SAMP>`\003'</SAMP>, the control-C
character).  That is the character which GDB uses to tell the
remote system to stop.

</P>
<P>
Getting the debugging target to return the proper status to GDB
probably requires changes to the standard stub; one quick and dirty way
is to just execute a breakpoint instruction (the "dirty" part is that
GDB reports a <CODE>SIGTRAP</CODE> instead of a <CODE>SIGINT</CODE>).

</P>
<P>
Other routines you need to supply are:

</P>
<DL COMPACT>

<DT><CODE>void exceptionHandler (int <VAR>exception_number</VAR>, void *<VAR>exception_address</VAR>)</CODE>
<DD>
<A NAME="IDX571"></A>
Write this function to install <VAR>exception_address</VAR> in the exception
handling tables.  You need to do this because the stub does not have any
way of knowing what the exception handling tables on your target system
are like (for example, the processor's table might be in ROM,
containing entries which point to a table in RAM).
<VAR>exception_number</VAR> is the exception number which should be changed;
its meaning is architecture-dependent (for example, different numbers
might represent divide by zero, misaligned access, etc).  When this
exception occurs, control should be transferred directly to
<VAR>exception_address</VAR>, and the processor state (stack, registers,
and so on) should be just as it is when a processor exception occurs.  So if
you want to use a jump instruction to reach <VAR>exception_address</VAR>, it
should be a simple jump, not a jump to subroutine.

For the 386, <VAR>exception_address</VAR> should be installed as an interrupt
gate so that interrupts are masked while the handler runs.  The gate
should be at privilege level 0 (the most privileged level).  The
SPARC and 68k stubs are able to mask interrupts themselves without
help from <CODE>exceptionHandler</CODE>.

<DT><CODE>void flush_i_cache()</CODE>
<DD>
<A NAME="IDX572"></A>
(sparc and sparclite only) Write this subroutine to flush the
instruction cache, if any, on your target machine.  If there is no
instruction cache, this subroutine may be a no-op.

On target machines that have instruction caches, GDB requires this
function to make certain that the state of your program is stable.
</DL>

<P>
You must also make sure this library routine is available:

</P>
<DL COMPACT>

<DT><CODE>void *memset(void *, int, int)</CODE>
<DD>
<A NAME="IDX573"></A>
This is the standard library function <CODE>memset</CODE> that sets an area of
memory to a known value.  If you have one of the free versions of
<CODE>libc.a</CODE>, <CODE>memset</CODE> can be found there; otherwise, you must
either obtain it from your hardware manufacturer, or write your own.
</DL>

<P>
If you do not use the GNU C compiler, you may need other standard
library subroutines as well; this varies from one stub to another,
but in general the stubs are likely to use any of the common library
subroutines which <CODE>gcc</CODE> generates as inline code.

</P>



<H4><A NAME="SEC120" HREF="gdb_toc.html#TOC120">Putting it all together</A></H4>

<P>
<A NAME="IDX574"></A>
In summary, when your program is ready to debug, you must follow these
steps.

</P>

<OL>
<LI>

Make sure you have the supporting low-level routines
(see section <A HREF="gdb_14.html#SEC119">What you must do for the stub</A>):

<PRE>
<CODE>getDebugChar</CODE>, <CODE>putDebugChar</CODE>,
<CODE>flush_i_cache</CODE>, <CODE>memset</CODE>, <CODE>exceptionHandler</CODE>.
</PRE>

<LI>

Insert these lines near the top of your program:


<PRE>
set_debug_traps();
breakpoint();
</PRE>

<LI>

For the 680x0 stub only, you need to provide a variable called
<CODE>exceptionHook</CODE>.  Normally you just use:


<PRE>
void (*exceptionHook)() = 0;
</PRE>

but if before calling <CODE>set_debug_traps</CODE>, you set it to point to a
function in your program, that function is called when
<CODE>GDB</CODE> continues after stopping on a trap (for example, bus
error).  The function indicated by <CODE>exceptionHook</CODE> is called with
one parameter: an <CODE>int</CODE> which is the exception number.

<LI>

Compile and link together: your program, the GDB debugging stub for
your target architecture, and the supporting subroutines.

<LI>

Make sure you have a serial connection between your target machine and
the GDB host, and identify the serial port on the host.

<LI>

Download your program to your target machine (or get it there by
whatever means the manufacturer provides), and start it.

<LI>

To start remote debugging, run GDB on the host machine, and specify
as an executable file the program that is running in the remote machine.
This tells GDB how to find your program's symbols and the contents
of its pure text.

<A NAME="IDX575"></A>
Then establish communication using the <CODE>target remote</CODE> command.
Its argument specifies how to communicate with the target
machine--either via a devicename attached to a direct serial line, or a
TCP port (usually to a terminal server which in turn has a serial line
to the target).  For example, to use a serial line connected to the
device named <TT>`/dev/ttyb'</TT>:


<PRE>
target remote /dev/ttyb
</PRE>

<A NAME="IDX576"></A>
To use a TCP connection, use an argument of the form
<CODE><VAR>host</VAR>:port</CODE>.  For example, to connect to port 2828 on a
terminal server named <CODE>manyfarms</CODE>:


<PRE>
target remote manyfarms:2828
</PRE>

</OL>

<P>
Now you can use all the usual commands to examine and change data and to
step and continue the remote program.

</P>
<P>
To resume the remote program and stop debugging it, use the <CODE>detach</CODE>
command.

</P>
<P>
<A NAME="IDX577"></A>
<A NAME="IDX578"></A>
Whenever GDB is waiting for the remote program, if you type the
interrupt character (often <KBD>C-C</KBD>), GDB attempts to stop the
program.  This may or may not succeed, depending in part on the hardware
and the serial drivers the remote system uses.  If you type the
interrupt character once again, GDB displays this prompt:

</P>

<PRE>
Interrupted while waiting for the program.
Give up (and stop debugging it)?  (y or n)
</PRE>

<P>
If you type <KBD>y</KBD>, GDB abandons the remote debugging session.
(If you decide you want to try again later, you can use <SAMP>`target
remote'</SAMP> again to connect once more.)  If you type <KBD>n</KBD>, GDB
goes back to waiting.

</P>


<H4><A NAME="SEC121" HREF="gdb_toc.html#TOC121">Communication protocol</A></H4>

<P>
<A NAME="IDX579"></A>
<A NAME="IDX580"></A>
<A NAME="IDX581"></A>
The stub files provided with GDB implement the target side of the
communication protocol, and the GDB side is implemented in the
GDB source file <TT>`remote.c'</TT>.  Normally, you can simply allow
these subroutines to communicate, and ignore the details.  (If you're
implementing your own stub file, you can still ignore the details: start
with one of the existing stub files.  <TT>`sparc-stub.c'</TT> is the best
organized, and therefore the easiest to read.)

</P>
<P>
However, there may be occasions when you need to know something about
the protocol--for example, if there is only one serial port to your
target machine, you might want your program to do something special if
it recognizes a packet meant for GDB.

</P>
<P>
In the examples below, <SAMP>`&#60;-'</SAMP> and <SAMP>`-&#62;'</SAMP> are used to indicate
transmitted and received data respectfully.

</P>
<P>
<A NAME="IDX582"></A>
<A NAME="IDX583"></A>
<A NAME="IDX584"></A>
All GDB commands and responses (other than acknowledgments)
are sent as a <VAR>packet</VAR>.  A <VAR>packet</VAR> is introduced with the
character <SAMP>`$'</SAMP>, this is followed by an optional two-digit
<VAR>sequence-id</VAR> and the character <SAMP>`:'</SAMP>, the actual
<VAR>packet-data</VAR>, and the terminating character <SAMP>`#'</SAMP> followed by a
two-digit <VAR>checksum</VAR>:

</P>

<PRE>
<CODE>$</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
</PRE>

<P>
or, with the optional <VAR>sequence-id</VAR>:

<PRE>
<CODE>$</CODE><VAR>sequence-id</VAR><CODE>:</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
</PRE>

<P>
<A NAME="IDX585"></A>
The two-digit <VAR>checksum</VAR> is computed as the modulo 256 sum of all
characters between the leading <SAMP>`$'</SAMP> and the trailing <SAMP>`#'</SAMP> (that
consisting of both the optional <VAR>sequence-id</VAR><CODE>:</CODE> and the actual
<VAR>packet-data</VAR>).

</P>
<P>
<A NAME="IDX586"></A>
The two-digit <VAR>sequence-id</VAR>, when present, is returned with the
acknowledgment.  Beyond that its meaning is poorly defined.
GDB is not known to output <VAR>sequence-id</VAR>s.

</P>
<P>
When either the host or the target machine receives a packet, the first
response expected is an acknowledgment: either <SAMP>`+'</SAMP> (to indicate
the package was received correctly) or <SAMP>`-'</SAMP> (to request
retransmission):

</P>

<PRE>
&#60;- <CODE>$</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
-&#62; <CODE>+</CODE>
</PRE>

<P>
If the received packet included a <VAR>sequence-id</VAR> than that is
appended to a positive acknowledgment:

</P>

<PRE>
&#60;- <CODE>$</CODE><VAR>sequence-id</VAR><CODE>:</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
-&#62; <CODE>+</CODE><VAR>sequence-id</VAR>
</PRE>

<P>
The host (GDB) sends <VAR>command</VAR>s, and the target (the
debugging stub incorporated in your program) sends a <VAR>response</VAR>.  In
the case of step and continue <VAR>command</VAR>s, the response is only sent
when the operation has completed (the target has again stopped).

</P>
<P>
<VAR>packet-data</VAR> consists of a sequence of characters with the
exception of <SAMP>`#'</SAMP> and <SAMP>`$'</SAMP> (see <SAMP>`X'</SAMP> packet for an
exception). <SAMP>`:'</SAMP> can not appear as the third character in a packet.
Fields within the packet should be separated using <SAMP>`,'</SAMP> and <SAMP>`;'</SAMP>
(unfortunately some packets chose to use <SAMP>`:'</SAMP>).  Except where
otherwise noted all numbers are represented in HEX with leading zeros
suppressed.

</P>
<P>
Response <VAR>data</VAR> can be run-length encoded to save space.  A <SAMP>`*'</SAMP>
means that the next character is an ASCII encoding giving a repeat count
which stands for that many repetitions of the character preceding the
<SAMP>`*'</SAMP>.  The encoding is <CODE>n+29</CODE>, yielding a printable character
where <CODE>n &#62;=3</CODE> (which is where rle starts to win).  Don't use an
<CODE>n &#62; 126</CODE>.

</P>
<P>
So:

<PRE>
"<CODE>0* </CODE>"
</PRE>

<P>
means the same as "0000".

</P>
<P>
The error response, returned for some packets includes a two character
error number.  That number is not well defined.

</P>
<P>
For any <VAR>command</VAR> not supported by the stub, an empty response
(<SAMP>`$#00'</SAMP>) should be returned.  That way it is possible to extend the
protocol.  A newer GDB can tell if a packet is supported based
on the response.

</P>
<P>
Below is a complete list of all currently defined <VAR>command</VAR>s and
their corresponding response <VAR>data</VAR>:

</P>
<P>
@multitable @columnfractions .30 .30 .40
<LI>Packet

@tab Request
@tab Description

<LI>extended ops <EM>(optional)</EM>

@tab <CODE>!</CODE>
@tab
Use the extended remote protocol. Sticky -- only needs to be set once.
The extended remote protocol support the <SAMP>`R'</SAMP> packet.
<LI>

@tab reply <SAMP>`'</SAMP>
@tab
Stubs that support the extended remote protocol return <SAMP>`'</SAMP> which,
unfortunately, is identical to the response returned by stubs that do not
support protocol extensions.

<LI>last signal

@tab <CODE>?</CODE>
@tab
Reply the current reason for stopping.  This is the same reply as is
generated for step or cont : <CODE>S</CODE><VAR>AA</VAR> where <VAR>AA</VAR> is the
signal number.

<LI>reserved

@tab <CODE>a</CODE>
@tab Reserved for future use 

<LI>set program arguments <STRONG>(reserved)</STRONG> <EM>(optional)</EM>

@tab <CODE>A</CODE><VAR>arglen</VAR><CODE>,</CODE><VAR>argnum</VAR><CODE>,</CODE><VAR>arg</VAR><CODE>,...</CODE>
@tab
Initialized <SAMP>`argv[]'</SAMP> array passed into program. <VAR>arglen</VAR>
specifies the number of bytes in the hex encoded byte stream <VAR>arg</VAR>.
<LI>

@tab reply <CODE>OK</CODE>
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>

<LI>set baud <STRONG>(deprecated)</STRONG>

@tab <CODE>b</CODE><VAR>baud</VAR>
@tab
Change the serial line speed to <VAR>baud</VAR>.  JTC: <EM>When does the
transport layer state change?  When it's received, or after the ACK is
transmitted.  In either case, there are problems if the command or the
acknowledgment packet is dropped.</EM> Stan: <EM>If people really wanted
to add something like this, and get it working for the first time, they
ought to modify ser-unix.c to send some kind of out-of-band message to a
specially-setup stub and have the switch happen "in between" packets, so
that from remote protocol's point of view, nothing actually
happened.</EM>

<LI>set breakpoint <STRONG>(deprecated)</STRONG>

@tab <CODE>B</CODE><VAR>addr</VAR>,<VAR>mode</VAR>
@tab
Set (<VAR>mode</VAR> is <SAMP>`S'</SAMP>) or clear (<VAR>mode</VAR> is <SAMP>`C'</SAMP>) a
breakpoint at <VAR>addr</VAR>.  <EM>This has been replaced by the <SAMP>`Z'</SAMP> and
<SAMP>`z'</SAMP> packets.</EM>

<LI>continue

@tab <CODE>c</CODE><VAR>addr</VAR>
@tab
<VAR>addr</VAR> is address to resume. If <VAR>addr</VAR> is omitted, resume at
current address.
<LI>

@tab reply
@tab see below

<LI>continue with signal <EM>(optional)</EM>

@tab <CODE>C</CODE><VAR>sig</VAR><CODE>;</CODE><VAR>addr</VAR>
@tab
Continue with signal <VAR>sig</VAR> (hex signal number).  If
<CODE>;</CODE><VAR>addr</VAR> is omitted, resume at same address.
<LI>

@tab reply
@tab see below

<LI>toggle debug <EM>(optional)</EM>

@tab <CODE>d</CODE>
@tab
toggle debug flag (see 386 &#38; 68k stubs)

<LI>detach <EM>(optional)</EM>

@tab <CODE>D</CODE>
@tab Reply OK.

<LI>reserved

@tab <CODE>e</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>E</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>f</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>F</CODE>
@tab Reserved for future use 

<LI>read registers

@tab <CODE>g</CODE>
@tab Read general registers.
<LI>

@tab reply <VAR>XX...</VAR>
@tab
Each byte of register data is described by two hex digits.  The bytes
with the register are transmitted in target byte order.  The size of
each register and their position within the <SAMP>`g'</SAMP> <VAR>packet</VAR> is
determined by the <VAR>REGISTER_RAW_SIZE</VAR> and <VAR>REGISTER_NAME</VAR>
macros.
<LI>

@tab <CODE>E</CODE><VAR>NN</VAR>
@tab for an error.

<LI>write regs

@tab <CODE>G</CODE><VAR>XX...</VAR>
@tab
See <SAMP>`g'</SAMP> for a description of the <VAR>XX...</VAR> data.
<LI>

@tab reply <CODE>OK</CODE>
@tab for success
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab for an error

<LI>reserved

@tab <CODE>h</CODE>
@tab Reserved for future use 

<LI>set thread <EM>(optional)</EM>

@tab <CODE>H</CODE><VAR>c</VAR><VAR>t...</VAR>
@tab
Set thread for subsequent operations.  <VAR>c</VAR> = <SAMP>`c'</SAMP> for thread
used in step and continue; <VAR>t...</VAR> can be -1 for all threads.
<VAR>c</VAR> = <SAMP>`g'</SAMP> for thread used in other operations.  If zero, pick a
thread, any thread.
<LI>

@tab reply <CODE>OK</CODE>
@tab for success
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab for an error

<LI>cycle step <STRONG>(draft)</STRONG> <EM>(optional)</EM>

@tab <CODE>i</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>nnn</VAR>
@tab
Step the remote target by a single clock cycle.  If <CODE>,</CODE><VAR>nnn</VAR> is
present, cycle step <VAR>nnn</VAR> cycles.  If <VAR>addr</VAR> is present, cycle
step starting at that address.

<LI>signal then cycle step <STRONG>(reserved)</STRONG> <EM>(optional)</EM>

@tab <CODE>I</CODE>
@tab
See <SAMP>`i'</SAMP> and <SAMP>`S'</SAMP> for likely syntax and semantics.

<LI>reserved

@tab <CODE>j</CODE>
@tab Reserved for future use

<LI>reserved

@tab <CODE>J</CODE>
@tab Reserved for future use 

<LI>kill request <EM>(optional)</EM>

@tab <CODE>k</CODE>
@tab

<LI>reserved

@tab <CODE>l</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>L</CODE>
@tab Reserved for future use 

<LI>read memory

@tab <CODE>m</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR>
@tab
Read <VAR>length</VAR> bytes of memory starting at address <VAR>addr</VAR>.
<LI>

@tab reply <VAR>XX...</VAR>
@tab
<VAR>XX...</VAR> is mem contents. Can be fewer bytes than requested if able to
read only part of the data.
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab <VAR>NN</VAR> is errno

<LI>write mem

@tab <CODE>M</CODE><VAR>addr</VAR>,<VAR>length</VAR><CODE>:</CODE><VAR>XX...</VAR>
@tab
Write <VAR>length</VAR> bytes of memory starting at address <VAR>addr</VAR>.
<VAR>XX...</VAR> is the data.
<LI>

@tab reply <CODE>OK</CODE>
@tab for success
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab
for an error (this includes the case where only part of the data was
written).

<LI>reserved

@tab <CODE>n</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>N</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>o</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>O</CODE>
@tab Reserved for future use 

<LI>read reg <STRONG>(reserved)</STRONG>

@tab <CODE>p</CODE><VAR>n...</VAR>
@tab
See write register.
<LI>

@tab return <VAR>r....</VAR>
@tab The hex encoded value of the register in target byte order.

<LI>write reg <EM>(optional)</EM>

@tab <CODE>P</CODE><VAR>n...</VAR><CODE>=</CODE><VAR>r...</VAR>
@tab
Write register <VAR>n...</VAR> with value <VAR>r...</VAR>, which contains two hex
digits for each byte in the register (target byte order).
<LI>

@tab reply <CODE>OK</CODE>
@tab for success
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab for an error

<LI>general query <EM>(optional)</EM>

@tab <CODE>q</CODE><VAR>query</VAR>
@tab
Request info about <VAR>query</VAR>. In general GDB <VAR>query</VAR>'s
have a leading upper case letter.  Custom vendor queries should use a
leading lower case letter and a company prefix, ex: <SAMP>`qfsf.var'</SAMP>.
<VAR>query</VAR> may optionally be followed by a <SAMP>`,'</SAMP> or <SAMP>`;'</SAMP>
separated list.  Stubs should ensure that they fully match any
<VAR>query</VAR> name.
<LI>

@tab reply <CODE>XX...</CODE>
@tab Hex encoded data from query. The reply can not be empty.
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab error reply
<LI>

@tab reply <SAMP>`'</SAMP>
@tab Indicating an unrecognized <VAR>query</VAR>.

<LI>current thread

@tab <CODE>q</CODE><CODE>C</CODE>
@tab Return the current thread id.
<LI>

@tab reply <CODE>QC</CODE><VAR>pid</VAR>
@tab
Where <VAR>pid</VAR> is a HEX encoded 16 bit process id.
<LI>

@tab reply *
@tab Any other reply implies the old pid.

<LI>compute CRC of memory block

@tab <CODE>q</CODE><CODE>CRC:</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR>
@tab
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab An error (such as memory fault)
<LI>

@tab reply <CODE>C</CODE><VAR>CRC32</VAR>
@tab A 32 bit cyclic redundancy check of the specified memory region.

<LI>query <VAR>LIST</VAR> or <VAR>threadLIST</VAR>

@tab <CODE>q</CODE><CODE>L</CODE><VAR>startflag</VAR><VAR>threadcount</VAR><VAR>nextthread</VAR>
@tab
Obtain thread information from RTOS.  <VAR>startflag</VAR> is one hex digit;
<VAR>threadcount</VAR> is two hex digits; and <VAR>nextthread</VAR> is 16 hex
digits.
<LI>

@tab reply *
@tab
See <CODE>remote.c:parse_threadlist_response()</CODE>.

<LI>query sect offs

@tab <CODE>q</CODE><CODE>Offsets</CODE>
@tab Get section offsets.
<LI>

@tab reply <CODE>Text=</CODE><VAR>xxx</VAR><CODE>;Data=</CODE><VAR>yyy</VAR><CODE>;Bss=</CODE><VAR>zzz</VAR>

<LI>thread info request

@tab <CODE>q</CODE><CODE>P</CODE><VAR>mode</VAR><VAR>threadid</VAR>
@tab
Returns information on <VAR>threadid</VAR>.  Where: <VAR>mode</VAR> is a hex
encoded 32 bit mode; <VAR>threadid</VAR> is a hex encoded 64 bit thread ID.
<LI>

@tab reply *
@tab
See <CODE>remote.c:remote_unpack_thread_info_response()</CODE>.

<LI>remote command <STRONG>(reserved)</STRONG>

@tab <CODE>q</CODE><CODE>Rcmd,</CODE><VAR>COMMAND</VAR>
@tab
<VAR>COMMAND</VAR> (hex encoded) is passed to the local interpreter for
execution.  <EM>Implementors should note that providing access to a
stubs's interpreter may have security implications</EM>.
<LI>

@tab reply <VAR>OUTPUT</VAR>
@tab
The <VAR>OUTPUT</VAR> (hex encoded).  Must be non-empty.
<LI>

@tab reply <SAMP>`'</SAMP>
@tab
When <SAMP>`q'</SAMP><SAMP>`Rcmd'</SAMP> is not recognized.

<LI>general set <EM>(optional)</EM>

@tab <CODE>Q</CODE><VAR>var</VAR><CODE>=</CODE><VAR>val</VAR>
@tab
Set value of <VAR>var</VAR> to <VAR>val</VAR>.  See <SAMP>`q'</SAMP> for a discussing of
naming conventions.

<LI>reset <EM>(optional)</EM>

@tab r
@tab reset -- see sparc stub.

<LI>remote restart <EM>(optional)</EM>

@tab <CODE>R</CODE><VAR>XX</VAR>
@tab
Restart the remote server. <VAR>XX</VAR> while needed has no clear
definition.

<LI>step <EM>(optional)</EM>

@tab <CODE>s</CODE><VAR>addr</VAR>
@tab
<VAR>addr</VAR> is address to resume.  If <VAR>addr</VAR> is omitted, resume at
same address.
<LI>

@tab reply
@tab see below

<LI>step with signal <EM>(optional)</EM>

@tab <CODE>S</CODE><VAR>sig</VAR><CODE>;</CODE><VAR>addr</VAR>
@tab
Like <SAMP>`C'</SAMP> but step not continue.
<LI>

@tab reply
@tab see below

<LI>search <EM>(optional)</EM>

@tab <CODE>t</CODE><VAR>addr</VAR><CODE>:</CODE><VAR>PP</VAR><CODE>,</CODE><VAR>MM</VAR>
@tab
Search backwards starting at address <VAR>addr</VAR> for a match with pattern
<VAR>PP</VAR> and mask <VAR>MM</VAR>.  <VAR>PP</VAR> and <VAR>MM</VAR> are 4
bytes. <VAR>addr</VAR> must be at least 3 digits.

<LI>thread alive <EM>(optional)</EM>

@tab <CODE>T</CODE><VAR>XX</VAR>
@tab Find out if the thread XX is alive.
<LI>

@tab reply <CODE>OK</CODE>
@tab thread is still alive
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab thread is dead
	
<LI>reserved

@tab <CODE>u</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>U</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>v</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>V</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>w</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>W</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>x</CODE>
@tab Reserved for future use 

<LI>write mem (binary) <EM>(optional)</EM>

@tab <CODE>X</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR><VAR>:</VAR><VAR>XX...</VAR>
@tab
<VAR>addr</VAR> is address, <VAR>length</VAR> is number of bytes, <VAR>XX...</VAR> is
binary data.
<LI>

@tab reply <CODE>OK</CODE>
@tab for success
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab for an error

<LI>reserved

@tab <CODE>y</CODE>
@tab Reserved for future use 

<LI>reserved

@tab <CODE>Y</CODE>
@tab Reserved for future use 

<LI>remove break or watchpoint <STRONG>(draft)</STRONG> <EM>(optional)</EM>

@tab <CODE>z</CODE><VAR>t</VAR><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR>
@tab
See <SAMP>`Z'</SAMP>.

<LI>insert break or watchpoint <STRONG>(draft)</STRONG> <EM>(optional)</EM>

@tab <CODE>Z</CODE><VAR>t</VAR><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR>
@tab
<VAR>t</VAR> is type: <SAMP>`0'</SAMP> - software breakpoint, <SAMP>`1'</SAMP> - hardware
breakpoint, <SAMP>`2'</SAMP> - write watchpoint, <SAMP>`3'</SAMP> - read watchpoint,
<SAMP>`4'</SAMP> - access watchpoint; <VAR>addr</VAR> is address; <VAR>length</VAR> is in
bytes.  For a software breakpoint, <VAR>length</VAR> specifies the size of
the instruction to be patched.  For hardware breakpoints and watchpoints
<VAR>length</VAR> specifies the memory region to be monitored.
<LI>

@tab reply <CODE>E</CODE><VAR>NN</VAR>
@tab for an error
<LI>

@tab reply <CODE>OK</CODE>
@tab for success
<LI>

@tab <SAMP>`'</SAMP>
@tab If not supported.

<LI>reserved

@tab &#60;other&#62;
@tab Reserved for future use 

In the case of the <SAMP>`C'</SAMP>, <SAMP>`c'</SAMP>, <SAMP>`S'</SAMP> and <SAMP>`s'</SAMP> packets,
there is no immediate response.  The reply, described below, comes when
the machine stops:

@multitable @columnfractions .4 .6

<LI><CODE>S</CODE><VAR>AA</VAR>

@tab <VAR>AA</VAR> is the signal number

<LI><CODE>T</CODE><VAR>AA</VAR><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE>

@tab
<VAR>AA</VAR> = two hex digit signal number; <VAR>n...</VAR> = register number
(hex), <VAR>r...</VAR>  = target byte ordered register contents, size defined
by <CODE>REGISTER_RAW_SIZE</CODE>; <VAR>n...</VAR> = <SAMP>`thread'</SAMP>, <VAR>r...</VAR> =
thread process ID, this is a hex integer; <VAR>n...</VAR> = other string not
starting with valid hex digit. GDB should ignore this
<VAR>n...</VAR>, <VAR>r...</VAR> pair and go on to the next.  This way we can
extend the protocol.

<LI><CODE>W</CODE><VAR>AA</VAR>

@tab
The process exited, and <VAR>AA</VAR> is the exit status.  This is only
applicable for certains sorts of targets.

<LI><CODE>X</CODE><VAR>AA</VAR>

@tab
The process terminated with signal <VAR>AA</VAR>.

<LI><CODE>N</CODE><VAR>AA</VAR><CODE>;</CODE><VAR>tttttttt</VAR><CODE>;</CODE><VAR>dddddddd</VAR><CODE>;</CODE><VAR>bbbbbbbb</VAR> <STRONG>(obsolete)</STRONG>

@tab
<VAR>AA</VAR> = signal number; <VAR>tttttttt</VAR> = address of symbol "_start";
<VAR>dddddddd</VAR> = base of data section; <VAR>bbbbbbbb</VAR> = base of bss
section. <EM>Note: only used by Cisco Systems targets.  The difference
between this reply and the "qOffsets" query is that the 'N' packet may
arrive spontaneously whereas the 'qOffsets' is a query initiated by the
host debugger.</EM>

<LI><CODE>O</CODE><VAR>XX...</VAR>

@tab
<VAR>XX...</VAR> is hex encoding of ASCII data. This can happen at any time
while the program is running and the debugger should continue to wait
for 'W', 'T', etc.

Example sequence of a target being re-started.  Notice how the restart
does not get any direct output:


<PRE>
&#60;- <CODE>R00</CODE>
-&#62; <CODE>+</CODE>
<EM>target restarts</EM>
&#60;- <CODE>?</CODE>
-&#62; <CODE>+</CODE>
-&#62; <CODE>T001:1234123412341234</CODE>
&#60;- <CODE>+</CODE>
</PRE>

Example sequence of a target being stepped by a single instruction:


<PRE>
&#60;- <CODE>G1445...</CODE>
-&#62; <CODE>+</CODE>
&#60;- <CODE>s</CODE>
-&#62; <CODE>+</CODE>
<EM>time passes</EM>
-&#62; <CODE>T001:1234123412341234</CODE>
&#60;- <CODE>+</CODE>
&#60;- <CODE>g</CODE>
-&#62; <CODE>+</CODE>
-&#62; <CODE>1455...</CODE>
&#60;- <CODE>+</CODE>
</PRE>

<A NAME="IDX587"></A>
<A NAME="IDX588"></A>
<A NAME="IDX589"></A>
<A NAME="IDX590"></A>
If you have trouble with the serial connection, you can use the command
<CODE>set remotedebug</CODE>.  This makes GDB report on all packets sent
back and forth across the serial line to the remote machine.  The
packet-debugging information is printed on the GDB standard output
stream.  <CODE>set remotedebug off</CODE> turns it off, and <CODE>show
remotedebug</CODE> shows you its current state.



<H4><A NAME="SEC122" HREF="gdb_toc.html#TOC122">Using the <CODE>gdbserver</CODE> program</A></H4>

<P>
<A NAME="IDX591"></A>
<A NAME="IDX592"></A>
<CODE>gdbserver</CODE> is a control program for Unix-like systems, which
allows you to connect your program with a remote GDB via
<CODE>target remote</CODE>---but without linking in the usual debugging stub.

</P>
<P>
<CODE>gdbserver</CODE> is not a complete replacement for the debugging stubs,
because it requires essentially the same operating-system facilities
that GDB itself does.  In fact, a system that can run
<CODE>gdbserver</CODE> to connect to a remote GDB could also run
GDB locally!  <CODE>gdbserver</CODE> is sometimes useful nevertheless,
because it is a much smaller program than GDB itself.  It is
also easier to port than all of GDB, so you may be able to get
started more quickly on a new system by using <CODE>gdbserver</CODE>.
Finally, if you develop code for real-time systems, you may find that
the tradeoffs involved in real-time operation make it more convenient to
do as much development work as possible on another system, for example
by cross-compiling.  You can use <CODE>gdbserver</CODE> to make a similar
choice for debugging.

</P>
<P>
GDB and <CODE>gdbserver</CODE> communicate via either a serial line
or a TCP connection, using the standard GDB remote serial
protocol.

</P>
<DL COMPACT>

<DT><EM>On the target machine,</EM>
<DD>
you need to have a copy of the program you want to debug.
<CODE>gdbserver</CODE> does not need your program's symbol table, so you can
strip the program if necessary to save space.  GDB on the host
system does all the symbol handling.

To use the server, you must tell it how to communicate with GDB;
the name of your program; and the arguments for your program.  The
syntax is:


<PRE>
target&#62; gdbserver <VAR>comm</VAR> <VAR>program</VAR> [ <VAR>args</VAR> ... ]
</PRE>

<VAR>comm</VAR> is either a device name (to use a serial line) or a TCP
hostname and portnumber.  For example, to debug Emacs with the argument
<SAMP>`foo.txt'</SAMP> and communicate with GDB over the serial port
<TT>`/dev/com1'</TT>:


<PRE>
target&#62; gdbserver /dev/com1 emacs foo.txt
</PRE>

<CODE>gdbserver</CODE> waits passively for the host GDB to communicate
with it.

To use a TCP connection instead of a serial line:


<PRE>
target&#62; gdbserver host:2345 emacs foo.txt
</PRE>

The only difference from the previous example is the first argument,
specifying that you are communicating with the host GDB via
TCP.  The <SAMP>`host:2345'</SAMP> argument means that <CODE>gdbserver</CODE> is to
expect a TCP connection from machine <SAMP>`host'</SAMP> to local TCP port 2345.
(Currently, the <SAMP>`host'</SAMP> part is ignored.)  You can choose any number
you want for the port number as long as it does not conflict with any
TCP ports already in use on the target system (for example, <CODE>23</CODE> is
reserved for <CODE>telnet</CODE>).<A NAME="DOCF4" HREF="gdb_foot.html#FOOT4">(4)</A> You must use the same port number with the host GDB
<CODE>target remote</CODE> command.

<DT><EM>On the GDB host machine,</EM>
<DD>
you need an unstripped copy of your program, since GDB needs
symbols and debugging information.  Start up GDB as usual,
using the name of the local copy of your program as the first argument.
(You may also need the <SAMP>`--baud'</SAMP> option if the serial line is
running at anything other than 9600 bps.)  After that, use <CODE>target
remote</CODE> to establish communications with <CODE>gdbserver</CODE>.  Its argument
is either a device name (usually a serial device, like
<TT>`/dev/ttyb'</TT>), or a TCP port descriptor in the form
<CODE><VAR>host</VAR>:<VAR>PORT</VAR></CODE>.  For example:


<PRE>
(gdb) target remote /dev/ttyb
</PRE>

communicates with the server via serial line <TT>`/dev/ttyb'</TT>, and


<PRE>
(gdb) target remote the-target:2345
</PRE>

communicates via a TCP connection to port 2345 on host <TT>`the-target'</TT>.
For TCP connections, you must start up <CODE>gdbserver</CODE> prior to using
the <CODE>target remote</CODE> command.  Otherwise you may get an error whose
text depends on the host system, but which usually looks something like
<SAMP>`Connection refused'</SAMP>.
</DL>



<H4><A NAME="SEC123" HREF="gdb_toc.html#TOC123">Using the <CODE>gdbserve.nlm</CODE> program</A></H4>

<P>
<A NAME="IDX593"></A>
<CODE>gdbserve.nlm</CODE> is a control program for NetWare systems, which
allows you to connect your program with a remote GDB via
<CODE>target remote</CODE>.

</P>
<P>
GDB and <CODE>gdbserve.nlm</CODE> communicate via a serial line,
using the standard GDB remote serial protocol.

</P>
<DL COMPACT>

<DT><EM>On the target machine,</EM>
<DD>
you need to have a copy of the program you want to debug.
<CODE>gdbserve.nlm</CODE> does not need your program's symbol table, so you
can strip the program if necessary to save space.  GDB on the
host system does all the symbol handling.

To use the server, you must tell it how to communicate with
GDB; the name of your program; and the arguments for your
program.  The syntax is:


<PRE>
load gdbserve [ BOARD=<VAR>board</VAR> ] [ PORT=<VAR>port</VAR> ]
              [ BAUD=<VAR>baud</VAR> ] <VAR>program</VAR> [ <VAR>args</VAR> ... ]
</PRE>

<VAR>board</VAR> and <VAR>port</VAR> specify the serial line; <VAR>baud</VAR> specifies
the baud rate used by the connection.  <VAR>port</VAR> and <VAR>node</VAR> default
to 0, <VAR>baud</VAR> defaults to 9600 bps.

For example, to debug Emacs with the argument <SAMP>`foo.txt'</SAMP>and
communicate with GDB over serial port number 2 or board 1 
using a 19200 bps connection:


<PRE>
load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt
</PRE>

<DT><EM>On the GDB host machine,</EM>
<DD>
you need an unstripped copy of your program, since GDB needs
symbols and debugging information.  Start up GDB as usual,
using the name of the local copy of your program as the first argument.
(You may also need the <SAMP>`--baud'</SAMP> option if the serial line is
running at anything other than 9600 bps.  After that, use <CODE>target
remote</CODE> to establish communications with <CODE>gdbserve.nlm</CODE>.  Its
argument is a device name (usually a serial device, like
<TT>`/dev/ttyb'</TT>).  For example:


<PRE>
(gdb) target remote /dev/ttyb
</PRE>

communications with the server via serial line <TT>`/dev/ttyb'</TT>.
</DL>



<H3><A NAME="SEC124" HREF="gdb_toc.html#TOC124">GDB with a remote i960 (Nindy)</A></H3>

<P>
<A NAME="IDX594"></A>
<A NAME="IDX595"></A>
<STRONG>Nindy</STRONG> is a ROM Monitor program for Intel 960 target systems.  When
GDB is configured to control a remote Intel 960 using Nindy, you can
tell GDB how to connect to the 960 in several ways:

</P>

<UL>
<LI>

Through command line options specifying serial port, version of the
Nindy protocol, and communications speed;

<LI>

By responding to a prompt on startup;

<LI>

By using the <CODE>target</CODE> command at any point during your GDB
session.  See section <A HREF="gdb_14.html#SEC114">Commands for managing targets</A>.

</UL>



<H4><A NAME="SEC125" HREF="gdb_toc.html#TOC125">Startup with Nindy</A></H4>

<P>
If you simply start <CODE>gdb</CODE> without using any command-line
options, you are prompted for what serial port to use, <EM>before</EM> you
reach the ordinary GDB prompt:

</P>

<PRE>
Attach /dev/ttyNN -- specify NN, or "quit" to quit:  
</PRE>

<P>
Respond to the prompt with whatever suffix (after <SAMP>`/dev/tty'</SAMP>)
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this and later wish to attach to Nindy,
use <CODE>target</CODE> (see section <A HREF="gdb_14.html#SEC114">Commands for managing targets</A>).

</P>


<H4><A NAME="SEC126" HREF="gdb_toc.html#TOC126">Options for Nindy</A></H4>

<P>
These are the startup options for beginning your GDB session with a
Nindy-960 board attached:

</P>
<DL COMPACT>

<DT><CODE>-r <VAR>port</VAR></CODE>
<DD>
Specify the serial port name of a serial interface to be used to connect
to the target system.  This option is only available when GDB is
configured for the Intel 960 target architecture.  You may specify
<VAR>port</VAR> as any of: a full pathname (e.g. <SAMP>`-r /dev/ttya'</SAMP>), a
device name in <TT>`/dev'</TT> (e.g. <SAMP>`-r ttya'</SAMP>), or simply the unique
suffix for a specific <CODE>tty</CODE> (e.g. <SAMP>`-r a'</SAMP>).

<DT><CODE>-O</CODE>
<DD>
(An uppercase letter "O", not a zero.)  Specify that GDB should use
the "old" Nindy monitor protocol to connect to the target system.
This option is only available when GDB is configured for the Intel 960
target architecture.


<BLOCKQUOTE>
<P>
<EM>Warning:</EM> if you specify <SAMP>`-O'</SAMP>, but are actually trying to
connect to a target system that expects the newer protocol, the connection
fails, appearing to be a speed mismatch.  GDB repeatedly
attempts to reconnect at several different line speeds.  You can abort
this process with an interrupt.
</BLOCKQUOTE>

<DT><CODE>-brk</CODE>
<DD>
Specify that GDB should first send a <CODE>BREAK</CODE> signal to the target
system, in an attempt to reset it, before connecting to a Nindy target.


<BLOCKQUOTE>
<P>
<EM>Warning:</EM> Many target systems do not have the hardware that this
requires; it only works with a few boards.
</BLOCKQUOTE>

</DL>

<P>
The standard <SAMP>`-b'</SAMP> option controls the line speed used on the serial
port.

</P>


<H4><A NAME="SEC127" HREF="gdb_toc.html#TOC127">Nindy reset command</A></H4>

<DL COMPACT>

<DT><CODE>reset</CODE>
<DD>
<A NAME="IDX596"></A>
For a Nindy target, this command sends a "break" to the remote target
system; this is only useful if the target has been equipped with a
circuit to perform a hard reset (or some other interesting action) when
a break is detected.
</DL>



<H3><A NAME="SEC128" HREF="gdb_toc.html#TOC128">The UDI protocol for AMD29K</A></H3>

<P>
<A NAME="IDX597"></A>
<A NAME="IDX598"></A>
GDB supports AMD's UDI ("Universal Debugger Interface")
protocol for debugging the a29k processor family.  To use this
configuration with AMD targets running the MiniMON monitor, you need the
program <CODE>MONTIP</CODE>, available from AMD at no charge.  You can also
use GDB with the UDI-conformant a29k simulator program
<CODE>ISSTIP</CODE>, also available from AMD.

</P>
<DL COMPACT>

<DT><CODE>target udi <VAR>keyword</VAR></CODE>
<DD>
<A NAME="IDX599"></A>
Select the UDI interface to a remote a29k board or simulator, where
<VAR>keyword</VAR> is an entry in the AMD configuration file <TT>`udi_soc'</TT>.
This file contains keyword entries which specify parameters used to
connect to a29k targets.  If the <TT>`udi_soc'</TT> file is not in your
working directory, you must set the environment variable <SAMP>`UDICONF'</SAMP>
to its pathname.
</DL>



<H3><A NAME="SEC129" HREF="gdb_toc.html#TOC129">The EBMON protocol for AMD29K</A></H3>

<P>
<A NAME="IDX600"></A>
<A NAME="IDX601"></A>

</P>
<P>
AMD distributes a 29K development board meant to fit in a PC, together
with a DOS-hosted monitor program called <CODE>EBMON</CODE>.  As a shorthand
term, this development system is called the "EB29K".  To use
GDB from a Unix system to run programs on the EB29K board, you
must first connect a serial cable between the PC (which hosts the EB29K
board) and a serial port on the Unix system.  In the following, we
assume you've hooked the cable between the PC's <TT>`COM1'</TT> port and
<TT>`/dev/ttya'</TT> on the Unix system.

</P>



<H4><A NAME="SEC130" HREF="gdb_toc.html#TOC130">Communications setup</A></H4>

<P>
The next step is to set up the PC's port, by doing something like this
in DOS on the PC:

</P>

<PRE>
C:\&#62; MODE com1:9600,n,8,1,none
</PRE>

<P>
This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry" action;
you must match the communications parameters when establishing the Unix
end of the connection as well.

</P>
<P>
To give control of the PC to the Unix side of the serial line, type
the following at the DOS console:

</P>

<PRE>
C:\&#62; CTTY com1
</PRE>

<P>
(Later, if you wish to return control to the DOS console, you can use
the command <CODE>CTTY con</CODE>---but you must send it over the device that
had control, in our example over the <TT>`COM1'</TT> serial line).

</P>
<P>
From the Unix host, use a communications program such as <CODE>tip</CODE> or
<CODE>cu</CODE> to communicate with the PC; for example,

</P>

<PRE>
cu -s 9600 -l /dev/ttya
</PRE>

<P>
The <CODE>cu</CODE> options shown specify, respectively, the linespeed and the
serial port to use.  If you use <CODE>tip</CODE> instead, your command line
may look something like the following:

</P>

<PRE>
tip -9600 /dev/ttya
</PRE>

<P>
Your system may require a different name where we show
<TT>`/dev/ttya'</TT> as the argument to <CODE>tip</CODE>.  The communications
parameters, including which port to use, are associated with the
<CODE>tip</CODE> argument in the "remote" descriptions file--normally the
system table <TT>`/etc/remote'</TT>.

</P>
<P>
<A NAME="IDX602"></A>
Using the <CODE>tip</CODE> or <CODE>cu</CODE> connection, change the DOS working
directory to the directory containing a copy of your 29K program, then
start the PC program <CODE>EBMON</CODE> (an EB29K control program supplied
with your board by AMD).  You should see an initial display from
<CODE>EBMON</CODE> similar to the one that follows, ending with the
<CODE>EBMON</CODE> prompt <SAMP>`#'</SAMP>---

</P>

<PRE>
C:\&#62; G:

G:\&#62; CD \usr\joe\work29k

G:\USR\JOE\WORK29K&#62; EBMON
Am29000 PC Coprocessor Board Monitor, version 3.0-18
Copyright 1990 Advanced Micro Devices, Inc.
Written by Gibbons and Associates, Inc.

Enter '?' or 'H' for help

PC Coprocessor Type   = EB29K
I/O Base              = 0x208
Memory Base           = 0xd0000

Data Memory Size      = 2048KB
Available I-RAM Range = 0x8000 to 0x1fffff
Available D-RAM Range = 0x80002000 to 0x801fffff

PageSize              = 0x400
Register Stack Size   = 0x800
Memory Stack Size     = 0x1800

CPU PRL               = 0x3
Am29027 Available     = No
Byte Write Available  = Yes

# ~.
</PRE>

<P>
Then exit the <CODE>cu</CODE> or <CODE>tip</CODE> program (done in the example by
typing <CODE>~.</CODE> at the <CODE>EBMON</CODE> prompt).  <CODE>EBMON</CODE> keeps
running, ready for GDB to take over.

</P>
<P>
For this example, we've assumed what is probably the most convenient
way to make sure the same 29K program is on both the PC and the Unix
system: a PC/NFS connection that establishes "drive <CODE>G:</CODE>" on the
PC as a file system on the Unix host.  If you do not have PC/NFS or
something similar connecting the two systems, you must arrange some
other way--perhaps floppy-disk transfer--of getting the 29K program
from the Unix system to the PC; GDB does <EM>not</EM> download it over the
serial line.

</P>


<H4><A NAME="SEC131" HREF="gdb_toc.html#TOC131">EB29K cross-debugging</A></H4>

<P>
Finally, <CODE>cd</CODE> to the directory containing an image of your 29K
program on the Unix system, and start GDB---specifying as argument the
name of your 29K program:

</P>

<PRE>
cd /usr/joe/work29k
gdb myfoo
</PRE>

<P>
Now you can use the <CODE>target</CODE> command:

</P>

<PRE>
target amd-eb /dev/ttya 9600 MYFOO
</PRE>

<P>
In this example, we've assumed your program is in a file called
<TT>`myfoo'</TT>.  Note that the filename given as the last argument to
<CODE>target amd-eb</CODE> should be the name of the program as it appears to DOS.
In our example this is simply <CODE>MYFOO</CODE>, but in general it can include
a DOS path, and depending on your transfer mechanism may not resemble
the name on the Unix side.

</P>
<P>
At this point, you can set any breakpoints you wish; when you are ready
to see your program run on the 29K board, use the GDB command
<CODE>run</CODE>.

</P>
<P>
To stop debugging the remote program, use the GDB <CODE>detach</CODE>
command.

</P>
<P>
To return control of the PC to its console, use <CODE>tip</CODE> or <CODE>cu</CODE>
once again, after your GDB session has concluded, to attach to
<CODE>EBMON</CODE>.  You can then type the command <CODE>q</CODE> to shut down
<CODE>EBMON</CODE>, returning control to the DOS command-line interpreter.
Type <CODE>CTTY con</CODE> to return command input to the main DOS console,
and type <KBD>~.</KBD> to leave <CODE>tip</CODE> or <CODE>cu</CODE>.

</P>


<H4><A NAME="SEC132" HREF="gdb_toc.html#TOC132">Remote log</A></H4>
<P>
<A NAME="IDX603"></A>
<A NAME="IDX604"></A>

</P>
<P>
The <CODE>target amd-eb</CODE> command creates a file <TT>`eb.log'</TT> in the
current working directory, to help debug problems with the connection.
<TT>`eb.log'</TT> records all the output from <CODE>EBMON</CODE>, including echoes
of the commands sent to it.  Running <SAMP>`tail -f'</SAMP> on this file in
another window often helps to understand trouble with <CODE>EBMON</CODE>, or
unexpected events on the PC side of the connection.

</P>


<H3><A NAME="SEC133" HREF="gdb_toc.html#TOC133">GDB with a Tandem ST2000</A></H3>

<P>
To connect your ST2000 to the host system, see the manufacturer's
manual.  Once the ST2000 is physically attached, you can run:

</P>

<PRE>
target st2000 <VAR>dev</VAR> <VAR>speed</VAR>
</PRE>

<P>
to establish it as your debugging environment.  <VAR>dev</VAR> is normally
the name of a serial device, such as <TT>`/dev/ttya'</TT>, connected to the
ST2000 via a serial line.  You can instead specify <VAR>dev</VAR> as a TCP
connection (for example, to a serial line attached via a terminal
concentrator) using the syntax <CODE><VAR>hostname</VAR>:<VAR>portnumber</VAR></CODE>.

</P>
<P>
The <CODE>load</CODE> and <CODE>attach</CODE> commands are <EM>not</EM> defined for
this target; you must load your program into the ST2000 as you normally
would for standalone operation.  GDB reads debugging information
(such as symbols) from a separate, debugging version of the program
available on your host computer.

</P>
<P>
<A NAME="IDX605"></A>
These auxiliary GDB commands are available to help you with the ST2000
environment:

</P>
<DL COMPACT>

<DT><CODE>st2000 <VAR>command</VAR></CODE>
<DD>
<A NAME="IDX606"></A>
<A NAME="IDX607"></A>
<A NAME="IDX608"></A>
Send a <VAR>command</VAR> to the STDBUG monitor.  See the manufacturer's
manual for available commands.

<DT><CODE>connect</CODE>
<DD>
<A NAME="IDX609"></A>
Connect the controlling terminal to the STDBUG command monitor.  When
you are done interacting with STDBUG, typing either of two character
sequences gets you back to the GDB command prompt:
<KBD><KBD>RET</KBD>~.</KBD> (Return, followed by tilde and period) or
<KBD><KBD>RET</KBD>~<KBD>C-d</KBD></KBD> (Return, followed by tilde and control-D).
</DL>



<H3><A NAME="SEC134" HREF="gdb_toc.html#TOC134">GDB and VxWorks</A></H3>

<P>
<A NAME="IDX610"></A>

</P>
<P>
GDB enables developers to spawn and debug tasks running on networked
VxWorks targets from a Unix host.  Already-running tasks spawned from
the VxWorks shell can also be debugged.  GDB uses code that runs on
both the Unix host and on the VxWorks target.  The program
<CODE>gdb</CODE> is installed and executed on the Unix host.  (It may be
installed with the name <CODE>vxgdb</CODE>, to distinguish it from a
GDB for debugging programs on the host itself.)

</P>
<DL COMPACT>

<DT><CODE>VxWorks-timeout <VAR>args</VAR></CODE>
<DD>
<A NAME="IDX611"></A>
All VxWorks-based targets now support the option <CODE>vxworks-timeout</CODE>.  
This option is set by the user, and  <VAR>args</VAR> represents the number of 
seconds GDB waits for responses to rpc's.  You might use this if 
your VxWorks target is a slow software simulator or is on the far side 
of a thin network line.
</DL>

<P>
The following information on connecting to VxWorks was current when
this manual was produced; newer releases of VxWorks may use revised
procedures.

</P>
<P>
<A NAME="IDX612"></A>
To use GDB with VxWorks, you must rebuild your VxWorks kernel
to include the remote debugging interface routines in the VxWorks
library <TT>`rdb.a'</TT>.  To do this, define <CODE>INCLUDE_RDB</CODE> in the
VxWorks configuration file <TT>`configAll.h'</TT> and rebuild your VxWorks
kernel.  The resulting kernel contains <TT>`rdb.a'</TT>, and spawns the
source debugging task <CODE>tRdbTask</CODE> when VxWorks is booted.  For more
information on configuring and remaking VxWorks, see the manufacturer's
manual.

</P>
<P>
Once you have included <TT>`rdb.a'</TT> in your VxWorks system image and set
your Unix execution search path to find GDB, you are ready to
run GDB.  From your Unix host, run <CODE>gdb</CODE> (or <CODE>vxgdb</CODE>,
depending on your installation).

</P>
<P>
GDB comes up showing the prompt:

</P>

<PRE>
(vxgdb)
</PRE>



<H4><A NAME="SEC135" HREF="gdb_toc.html#TOC135">Connecting to VxWorks</A></H4>

<P>
The GDB command <CODE>target</CODE> lets you connect to a VxWorks target on the
network.  To connect to a target whose host name is "<CODE>tt</CODE>", type:

</P>

<PRE>
(vxgdb) target vxworks tt
</PRE>

<P>
GDB displays messages like these:

</P>

<PRE>
Attaching remote machine across net... 
Connected to tt.
</PRE>

<P>
GDB then attempts to read the symbol tables of any object modules
loaded into the VxWorks target since it was last booted.  GDB locates
these files by searching the directories listed in the command search
path (see section <A HREF="gdb_5.html#SEC19">Your program's environment</A>); if it fails
to find an object file, it displays a message such as:

</P>

<PRE>
prog.o: No such file or directory.
</PRE>

<P>
When this happens, add the appropriate directory to the search path with
the GDB command <CODE>path</CODE>, and execute the <CODE>target</CODE>
command again.

</P>


<H4><A NAME="SEC136" HREF="gdb_toc.html#TOC136">VxWorks download</A></H4>

<P>
<A NAME="IDX613"></A>
If you have connected to the VxWorks target and you want to debug an
object that has not yet been loaded, you can use the GDB
<CODE>load</CODE> command to download a file from Unix to VxWorks
incrementally.  The object file given as an argument to the <CODE>load</CODE>
command is actually opened twice: first by the VxWorks target in order
to download the code, then by GDB in order to read the symbol
table.  This can lead to problems if the current working directories on
the two systems differ.  If both systems have NFS mounted the same
filesystems, you can avoid these problems by using absolute paths.
Otherwise, it is simplest to set the working directory on both systems
to the directory in which the object file resides, and then to reference
the file by its name, without any path.  For instance, a program
<TT>`prog.o'</TT> may reside in <TT>`<VAR>vxpath</VAR>/vw/demo/rdb'</TT> in VxWorks
and in <TT>`<VAR>hostpath</VAR>/vw/demo/rdb'</TT> on the host.  To load this
program, type this on VxWorks:

</P>

<PRE>
-&#62; cd "<VAR>vxpath</VAR>/vw/demo/rdb"
</PRE>

<P>
v
Then, in GDB, type:

</P>

<PRE>
(vxgdb) cd <VAR>hostpath</VAR>/vw/demo/rdb 
(vxgdb) load prog.o
</PRE>

<P>
GDB displays a response similar to this:

</P>

<PRE>
Reading symbol data from wherever/vw/demo/rdb/prog.o... done.
</PRE>

<P>
You can also use the <CODE>load</CODE> command to reload an object module
after editing and recompiling the corresponding source file.  Note that
this makes GDB delete all currently-defined breakpoints,
auto-displays, and convenience variables, and to clear the value
history.  (This is necessary in order to preserve the integrity of
debugger data structures that reference the target system's symbol
table.)

</P>


<H4><A NAME="SEC137" HREF="gdb_toc.html#TOC137">Running tasks</A></H4>

<P>
<A NAME="IDX614"></A>
You can also attach to an existing task using the <CODE>attach</CODE> command as
follows:

</P>

<PRE>
(vxgdb) attach <VAR>task</VAR>
</PRE>

<P>
where <VAR>task</VAR> is the VxWorks hexadecimal task ID.  The task can be running
or suspended when you attach to it.  Running tasks are suspended at
the time of attachment.

</P>


<H3><A NAME="SEC138" HREF="gdb_toc.html#TOC138">GDB and Sparclet</A></H3>
<P>
<A NAME="IDX615"></A>

</P>
<P>
GDB enables developers to debug tasks running on 
Sparclet targets from a Unix host.  
GDB uses code that runs on
both the Unix host and on the Sparclet target.  The program
<CODE>gdb</CODE> is installed and executed on the Unix host.  

</P>
<DL COMPACT>

<DT><CODE>timeout <VAR>args</VAR></CODE>
<DD>
<A NAME="IDX616"></A>
GDB now supports the option <CODE>remotetimeout</CODE>.  
This option is set by the user, and  <VAR>args</VAR> represents the number of 
seconds GDB waits for responses.  
</DL>

<P>
<A NAME="IDX617"></A>
When compiling for debugging, include the options "-g" to get debug 
information and "-Ttext" to relocate the program to where you wish to
load it on the target.  You may also want to add the options "-n" or 
"-N" in order to reduce the size of the sections.

</P>

<PRE>
sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N
</PRE>

<P>
You can use objdump to verify that the addresses are what you intended.

</P>

<PRE>
sparclet-aout-objdump --headers --syms prog
</PRE>

<P>
<A NAME="IDX618"></A>
Once you have set
your Unix execution search path to find GDB, you are ready to
run GDB.  From your Unix host, run <CODE>gdb</CODE> 
(or <CODE>sparclet-aout-gdb</CODE>, depending on your installation).

</P>
<P>
GDB comes up showing the prompt:

</P>

<PRE>
(gdbslet)
</PRE>



<H4><A NAME="SEC139" HREF="gdb_toc.html#TOC139">Setting file to debug</A></H4>

<P>
The GDB command <CODE>file</CODE> lets you choose with program to debug.

</P>

<PRE>
(gdbslet) file prog
</PRE>

<P>
GDB then attempts to read the symbol table of <TT>`prog'</TT>.
GDB locates
the file by searching the directories listed in the command search
path.
If the file was compiled with debug information (option "-g"), source
files will be searched as well.
GDB locates
the source files by searching the directories listed in the directory search
path (see section <A HREF="gdb_5.html#SEC19">Your program's environment</A>).
If it fails
to find a file, it displays a message such as:

</P>

<PRE>
prog: No such file or directory.
</PRE>

<P>
When this happens, add the appropriate directories to the search paths with
the GDB commands <CODE>path</CODE> and <CODE>dir</CODE>, and execute the 
<CODE>target</CODE> command again.

</P>


<H4><A NAME="SEC140" HREF="gdb_toc.html#TOC140">Connecting to Sparclet</A></H4>

<P>
The GDB command <CODE>target</CODE> lets you connect to a Sparclet target.
To connect to a target on serial port "<CODE>ttya</CODE>", type:

</P>

<PRE>
(gdbslet) target sparclet /dev/ttya
Remote target sparclet connected to /dev/ttya
main () at ../prog.c:3 
</PRE>

<P>
GDB displays messages like these:

</P>

<PRE>
Connected to ttya.
</PRE>



<H4><A NAME="SEC141" HREF="gdb_toc.html#TOC141">Sparclet download</A></H4>

<P>
<A NAME="IDX619"></A>
Once connected to the Sparclet target, 
you can use the GDB
<CODE>load</CODE> command to download the file from the host to the target.
The file name and load offset should be given as arguments to the <CODE>load</CODE>
command.
Since the file format is aout, the program must be loaded to the starting 
address.  You can use objdump to find out what this value is.  The load
offset is an offset which is added to the VMA (virtual memory address)
of each of the file's sections.
For instance, if the program
<TT>`prog'</TT> was linked to text address 0x1201000, with data at 0x12010160
and bss at 0x12010170, in GDB, type:

</P>

<PRE>
(gdbslet) load prog 0x12010000
Loading section .text, size 0xdb0 vma 0x12010000
</PRE>

<P>
If the code is loaded at a different address then what the program was linked 
to, you may need to use the <CODE>section</CODE> and <CODE>add-symbol-file</CODE> commands 
to tell GDB where to map the symbol table.

</P>


<H4><A NAME="SEC142" HREF="gdb_toc.html#TOC142">Running and debugging</A></H4>

<P>
<A NAME="IDX620"></A>
You can now begin debugging the task using GDB's execution control
commands, <CODE>b</CODE>, <CODE>step</CODE>, <CODE>run</CODE>, etc.  See the GDB 
manual for the list of commands.

</P>

<PRE>
(gdbslet) b main
Breakpoint 1 at 0x12010000: file prog.c, line 3.
(gdbslet) run 
Starting program: prog
Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
3        char *symarg = 0;
(gdbslet) step
4        char *execarg = "hello!";
(gdbslet)                           
</PRE>



<H3><A NAME="SEC143" HREF="gdb_toc.html#TOC143">GDB and Hitachi microprocessors</A></H3>
<P>
GDB needs to know these things to talk to your
Hitachi SH, H8/300, or H8/500: 

</P>

<OL>
<LI>

that you want to use <SAMP>`target hms'</SAMP>, the remote debugging interface
for Hitachi microprocessors, or <SAMP>`target e7000'</SAMP>, the in-circuit
emulator for the Hitachi SH and the Hitachi 300H.  (<SAMP>`target hms'</SAMP> is
the default when GDB is configured specifically for the Hitachi SH,
H8/300, or H8/500.)

<LI>

what serial device connects your host to your Hitachi board (the first
serial device available on your host is the default).

<LI>

what speed to use over the serial device.
</OL>



<H4><A NAME="SEC144" HREF="gdb_toc.html#TOC144">Connecting to Hitachi boards</A></H4>

<P>
<A NAME="IDX621"></A>
<A NAME="IDX622"></A>
Use the special <CODE>gdb</CODE> command <SAMP>`device <VAR>port</VAR>'</SAMP> if you
need to explicitly set the serial device.  The default <VAR>port</VAR> is the
first available port on your host.  This is only necessary on Unix
hosts, where it is typically something like <TT>`/dev/ttya'</TT>.

</P>
<P>
<A NAME="IDX623"></A>
<A NAME="IDX624"></A>
<CODE>gdb</CODE> has another special command to set the communications
speed: <SAMP>`speed <VAR>bps</VAR>'</SAMP>.  This command also is only used from Unix
hosts; on DOS hosts, set the line speed as usual from outside GDB with
the DOS <KBD>mode</KBD> command (for instance, <SAMP>`mode
com2:9600,n,8,1,p'</SAMP> for a 9600 bps connection).

</P>
<P>
The <SAMP>`device'</SAMP> and <SAMP>`speed'</SAMP> commands are available only when you
use a Unix host to debug your Hitachi microprocessor programs.  If you
use a DOS host,
GDB depends on an auxiliary terminate-and-stay-resident program
called <CODE>asynctsr</CODE> to communicate with the development board
through a PC serial port.  You must also use the DOS <CODE>mode</CODE> command
to set up the serial port on the DOS side.

</P>
<P>
The following sample session illustrates the steps needed to start a
program under GDB control on an H8/300.  The example uses a
sample H8/300 program called <TT>`t.x'</TT>.  The procedure is the same for
the Hitachi SH and the H8/500.

</P>
<P>
First hook up your development board.  In this example, we use a
board attached to serial port <CODE>COM2</CODE>; if you use a different serial
port, substitute its name in the argument of the <CODE>mode</CODE> command.
When you call <CODE>asynctsr</CODE>, the auxiliary comms program used by the
degugger, you give it just the numeric part of the serial port's name;
for example, <SAMP>`asyncstr 2'</SAMP> below runs <CODE>asyncstr</CODE> on
<CODE>COM2</CODE>.

</P>

<PRE>
C:\H8300\TEST&#62; asynctsr 2
C:\H8300\TEST&#62; mode com2:9600,n,8,1,p

Resident portion of MODE loaded

COM2: 9600, n, 8, 1, p

</PRE>


<BLOCKQUOTE>
<P>
<EM>Warning:</EM> We have noticed a bug in PC-NFS that conflicts with
<CODE>asynctsr</CODE>.  If you also run PC-NFS on your DOS host, you may need to
disable it, or even boot without it, to use <CODE>asynctsr</CODE> to control
your development board.
</BLOCKQUOTE>

<P>
<A NAME="IDX625"></A>
Now that serial communications are set up, and the development board is
connected, you can start up GDB.  Call <CODE>gdb</CODE> with
the name of your program as the argument.  <CODE>gdb</CODE> prompts
you, as usual, with the prompt <SAMP>`(gdb)'</SAMP>.  Use two special
commands to begin your debugging session: <SAMP>`target hms'</SAMP> to specify
cross-debugging to the Hitachi board, and the <CODE>load</CODE> command to
download your program to the board.  <CODE>load</CODE> displays the names of
the program's sections, and a <SAMP>`*'</SAMP> for each 2K of data downloaded.
(If you want to refresh GDB data on symbols or on the
executable file without downloading, use the GDB commands
<CODE>file</CODE> or <CODE>symbol-file</CODE>.  These commands, and <CODE>load</CODE>
itself, are described in section <A HREF="gdb_13.html#SEC110">Commands to specify files</A>.)

</P>

<PRE>
(eg-C:\H8300\TEST) gdb t.x
GDB is free software and you are welcome to distribute copies
 of it under certain conditions; type "show copying" to see 
 the conditions.
There is absolutely no warranty for GDB; type "show warranty" 
for details.
GDB 19990707, Copyright 1992 Free Software Foundation, Inc...
(gdb) target hms
Connected to remote H8/300 HMS system.
(gdb) load t.x
.text   : 0x8000 .. 0xabde ***********
.data   : 0xabde .. 0xad30 *
.stack  : 0xf000 .. 0xf014 *
</PRE>

<P>
At this point, you're ready to run or debug your program.  From here on,
you can use all the usual GDB commands.  The <CODE>break</CODE> command
sets breakpoints; the <CODE>run</CODE> command starts your program;
<CODE>print</CODE> or <CODE>x</CODE> display data; the <CODE>continue</CODE> command
resumes execution after stopping at a breakpoint.  You can use the
<CODE>help</CODE> command at any time to find out more about GDB commands.

</P>
<P>
Remember, however, that <EM>operating system</EM> facilities aren't
available on your development board; for example, if your program hangs,
you can't send an interrupt--but you can press the RESET switch!

</P>
<P>
Use the RESET button on the development board

<UL>
<LI>

to interrupt your program (don't use <KBD>ctl-C</KBD> on the DOS host--it has
no way to pass an interrupt signal to the development board); and

<LI>

to return to the GDB command prompt after your program finishes
normally.  The communications protocol provides no other way for GDB
to detect program completion.
</UL>

<P>
In either case, GDB sees the effect of a RESET on the
development board as a "normal exit" of your program.

</P>


<H4><A NAME="SEC145" HREF="gdb_toc.html#TOC145">Using the E7000 in-circuit emulator</A></H4>

<P>
<A NAME="IDX626"></A>
You can use the E7000 in-circuit emulator to develop code for either the
Hitachi SH or the H8/300H.  Use one of these forms of the <SAMP>`target
e7000'</SAMP> command to connect GDB to your E7000:

</P>
<DL COMPACT>

<DT><CODE>target e7000 <VAR>port</VAR> <VAR>speed</VAR></CODE>
<DD>
Use this form if your E7000 is connected to a serial port.  The
<VAR>port</VAR> argument identifies what serial port to use (for example,
<SAMP>`com2'</SAMP>).  The third argument is the line speed in bits per second
(for example, <SAMP>`9600'</SAMP>).

<DT><CODE>target e7000 <VAR>hostname</VAR></CODE>
<DD>
If your E7000 is installed as a host on a TCP/IP network, you can just
specify its hostname; GDB uses <CODE>telnet</CODE> to connect.
</DL>



<H4><A NAME="SEC146" HREF="gdb_toc.html#TOC146">Special GDB commands for Hitachi micros</A></H4>

<P>
Some GDB commands are available only on the H8/300 or the
H8/500 configurations:

</P>
<DL COMPACT>

<DT><CODE>set machine h8300</CODE>
<DD>
<A NAME="IDX627"></A>
 <A NAME="IDX628"></A>
 
<DT><CODE>set machine h8300h</CODE>
<DD>
Condition GDB for one of the two variants of the H8/300
architecture with <SAMP>`set machine'</SAMP>.  You can use <SAMP>`show machine'</SAMP>
to check which variant is currently in effect.

<A NAME="IDX629"></A>
<A NAME="IDX630"></A>
<DT><CODE>set memory <VAR>mod</VAR></CODE>
<DD>
<DT><CODE>show memory</CODE>
<DD>
Specify which H8/500 memory model (<VAR>mod</VAR>) you are using with
<SAMP>`set memory'</SAMP>; check which memory model is in effect with <SAMP>`show
memory'</SAMP>.  The accepted values for <VAR>mod</VAR> are <CODE>small</CODE>,
<CODE>big</CODE>, <CODE>medium</CODE>, and <CODE>compact</CODE>.
</DL>



<H3><A NAME="SEC147" HREF="gdb_toc.html#TOC147">GDB and remote MIPS boards</A></H3>

<P>
<A NAME="IDX631"></A>
GDB can use the MIPS remote debugging protocol to talk to a
MIPS board attached to a serial line.  This is available when
you configure GDB with <SAMP>`--target=mips-idt-ecoff'</SAMP>.

</P>
<P>
Use these GDB commands to specify the connection to your target board:

</P>
<DL COMPACT>

<DT><CODE>target mips <VAR>port</VAR></CODE>
<DD>
<A NAME="IDX632"></A>
To run a program on the board, start up <CODE>gdb</CODE> with the
name of your program as the argument.  To connect to the board, use the
command <SAMP>`target mips <VAR>port</VAR>'</SAMP>, where <VAR>port</VAR> is the name of
the serial port connected to the board.  If the program has not already
been downloaded to the board, you may use the <CODE>load</CODE> command to
download it.  You can then use all the usual GDB commands.

For example, this sequence connects to the target board through a serial
port, and loads and runs a program called <VAR>prog</VAR> through the
debugger:


<PRE>
host$ gdb <VAR>prog</VAR>
GDB is free software and ...
(gdb) target mips /dev/ttyb
(gdb) load <VAR>prog</VAR>
(gdb) run
</PRE>

<DT><CODE>target mips <VAR>hostname</VAR>:<VAR>portnumber</VAR></CODE>
<DD>
On some GDB host configurations, you can specify a TCP
connection (for instance, to a serial line managed by a terminal
concentrator) instead of a serial port, using the syntax
<SAMP>`<VAR>hostname</VAR>:<VAR>portnumber</VAR>'</SAMP>.

<DT><CODE>target pmon <VAR>port</VAR></CODE>
<DD>
<A NAME="IDX633"></A>

<DT><CODE>target ddb <VAR>port</VAR></CODE>
<DD>
<A NAME="IDX634"></A>

<DT><CODE>target lsi <VAR>port</VAR></CODE>
<DD>
<A NAME="IDX635"></A>

</DL>

<P>
GDB also supports these special commands for MIPS targets:

</P>
<DL COMPACT>

<DT><CODE>set processor <VAR>args</VAR></CODE>
<DD>
<DT><CODE>show processor</CODE>
<DD>
<A NAME="IDX636"></A>
<A NAME="IDX637"></A>
Use the <CODE>set processor</CODE> command to set the type of MIPS
processor when you want to access processor-type-specific registers.
For example, <CODE>set processor <VAR>r3041</VAR></CODE> tells GDB 
to use the CPO registers appropriate for the 3041 chip.
Use the <CODE>show processor</CODE> command to see what MIPS processor GDB 
is using.  Use the <CODE>info reg</CODE> command to see what registers
GDB is using. 

<DT><CODE>set mipsfpu double</CODE>
<DD>
<DT><CODE>set mipsfpu single</CODE>
<DD>
<DT><CODE>set mipsfpu none</CODE>
<DD>
<DT><CODE>show mipsfpu</CODE>
<DD>
<A NAME="IDX638"></A>
<A NAME="IDX639"></A>
<A NAME="IDX640"></A>
<A NAME="IDX641"></A>
If your target board does not support the MIPS floating point
coprocessor, you should use the command <SAMP>`set mipsfpu none'</SAMP> (if you
need this, you may wish to put the command in your 
file).  This tells GDB how to find the return value of
functions which return floating point values.  It also allows
GDB to avoid saving the floating point registers when calling
functions on the board.  If you are using a floating point coprocessor
with only single precision floating point support, as on the R4650
processor, use the command <SAMP>`set mipsfpu single'</SAMP>.  The default
double precision floating point coprocessor may be selected using
<SAMP>`set mipsfpu double'</SAMP>.

In previous versions the only choices were double precision or no
floating point, so <SAMP>`set mipsfpu on'</SAMP> will select double precision
and <SAMP>`set mipsfpu off'</SAMP> will select no floating point.

As usual, you can inquire about the <CODE>mipsfpu</CODE> variable with
<SAMP>`show mipsfpu'</SAMP>.

<DT><CODE>set remotedebug <VAR>n</VAR></CODE>
<DD>
<DT><CODE>show remotedebug</CODE>
<DD>
<A NAME="IDX642"></A>
<A NAME="IDX643"></A>
<A NAME="IDX644"></A>
<A NAME="IDX645"></A>
You can see some debugging information about communications with the board
by setting the <CODE>remotedebug</CODE> variable.  If you set it to <CODE>1</CODE> using
<SAMP>`set remotedebug 1'</SAMP>, every packet is displayed.  If you set it
to <CODE>2</CODE>, every character is displayed.  You can check the current value
at any time with the command <SAMP>`show remotedebug'</SAMP>.

<DT><CODE>set timeout <VAR>seconds</VAR></CODE>
<DD>
<DT><CODE>set retransmit-timeout <VAR>seconds</VAR></CODE>
<DD>
<DT><CODE>show timeout</CODE>
<DD>
<DT><CODE>show retransmit-timeout</CODE>
<DD>
<A NAME="IDX646"></A>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>
<A NAME="IDX649"></A>
<A NAME="IDX650"></A>
<A NAME="IDX651"></A>
You can control the timeout used while waiting for a packet, in the MIPS
remote protocol, with the <CODE>set timeout <VAR>seconds</VAR></CODE> command.  The
default is 5 seconds.  Similarly, you can control the timeout used while
waiting for an acknowledgement of a packet with the <CODE>set
retransmit-timeout <VAR>seconds</VAR></CODE> command.  The default is 3 seconds.
You can inspect both values with <CODE>show timeout</CODE> and <CODE>show
retransmit-timeout</CODE>.  (These commands are <EM>only</EM> available when
GDB is configured for <SAMP>`--target=mips-idt-ecoff'</SAMP>.)

The timeout set by <CODE>set timeout</CODE> does not apply when GDB
is waiting for your program to stop.  In that case, GDB waits
forever because it has no way of knowing how long the program is going
to run before stopping.
</DL>



<H3><A NAME="SEC148" HREF="gdb_toc.html#TOC148">Simulated CPU target</A></H3>

<P>
<A NAME="IDX652"></A>
<A NAME="IDX653"></A>
<A NAME="IDX654"></A>
<A NAME="IDX655"></A>
<A NAME="IDX656"></A>
<A NAME="IDX657"></A>
<A NAME="IDX658"></A>
<A NAME="IDX659"></A>
For some configurations, GDB includes a CPU simulator that you
can use instead of a hardware CPU to debug your programs.
Currently, simulators are available for ARM, D10V, D30V, FR30, H8/300,
H8/500, i960, M32R, MIPS, MN10200, MN10300, PowerPC, SH, Sparc, V850,
W65, and Z8000.

</P>
<P>
<A NAME="IDX660"></A>
<A NAME="IDX661"></A>
When configured for debugging Zilog Z8000 targets, GDB includes
a Z8000 simulator.

</P>
<P>
For the Z8000 family, <SAMP>`target sim'</SAMP> simulates either the Z8002 (the
unsegmented variant of the Z8000 architecture) or the Z8001 (the
segmented variant).  The simulator recognizes which architecture is
appropriate by inspecting the object code.

</P>
<DL COMPACT>

<DT><CODE>target sim <VAR>args</VAR></CODE>
<DD>
<A NAME="IDX662"></A>
<A NAME="IDX663"></A>
Debug programs on a simulated CPU.  If the simulator supports setup
options, specify them via <VAR>args</VAR>.
</DL>

<P>
After specifying this target, you can debug programs for the simulated
CPU in the same style as programs for your host computer; use the
<CODE>file</CODE> command to load a new program image, the <CODE>run</CODE> command
to run your program, and so on.

</P>
<P>
As well as making available all the usual machine registers (see
<CODE>info reg</CODE>), the Z8000 simulator provides three additional items
of information as specially named registers:

</P>
<DL COMPACT>

<DT><CODE>cycles</CODE>
<DD>
Counts clock-ticks in the simulator.

<DT><CODE>insts</CODE>
<DD>
Counts instructions run in the simulator.

<DT><CODE>time</CODE>
<DD>
Execution time in 60ths of a second. 
</DL>

<P>
You can refer to these values in GDB expressions with the usual
conventions; for example, <SAMP>`b fputc if $cycles&#62;5000'</SAMP> sets a
conditional breakpoint that suspends only after at least 5000
simulated clock ticks.

</P>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_13.html">previous</A>, <A HREF="gdb_15.html">next</A>, <A HREF="gdb_21.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
