<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from /mnt/apple/gdb/source/gdb.apple/source/gdb/gdb/doc/gdb.texinfo on 23 November 1999 -->

<TITLE>Debugging with GDB - Examining Data</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_8.html">previous</A>, <A HREF="gdb_10.html">next</A>, <A HREF="gdb_21.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC51" HREF="gdb_toc.html#TOC51">Examining Data</A></H1>

<P>
<A NAME="IDX263"></A>
<A NAME="IDX264"></A>
<A NAME="IDX265"></A>
<A NAME="IDX266"></A>
The usual way to examine data in your program is with the <CODE>print</CODE>
command (abbreviated <CODE>p</CODE>), or its synonym <CODE>inspect</CODE>.  It
evaluates and prints the value of an expression of the language your
program is written in (see section <A HREF="gdb_10.html#SEC63">Using GDB with Different Languages</A>).

</P>
<DL COMPACT>

<DT><CODE>print <VAR>exp</VAR></CODE>
<DD>
<DT><CODE>print /<VAR>f</VAR> <VAR>exp</VAR></CODE>
<DD>
<VAR>exp</VAR> is an expression (in the source language).  By default the
value of <VAR>exp</VAR> is printed in a format appropriate to its data type;
you can choose a different format by specifying <SAMP>`/<VAR>f</VAR>'</SAMP>, where
<VAR>f</VAR> is a letter specifying the format; see section <A HREF="gdb_9.html#SEC55">Output formats</A>.

<DT><CODE>print</CODE>
<DD>
<DT><CODE>print /<VAR>f</VAR></CODE>
<DD>
If you omit <VAR>exp</VAR>, GDB displays the last value again (from the
<STRONG>value history</STRONG>; see section <A HREF="gdb_9.html#SEC59">Value history</A>).  This allows you to
conveniently inspect the same value in an alternative format.
</DL>

<P>
A more low-level way of examining data is with the <CODE>x</CODE> command.
It examines data in memory at a specified address and prints it in a
specified format.  See section <A HREF="gdb_9.html#SEC56">Examining memory</A>.

</P>
<P>
If you are interested in information about types, or about how the
fields of a struct or class are declared, use the <CODE>ptype <VAR>exp</VAR></CODE>
command rather than <CODE>print</CODE>. See section <A HREF="gdb_11.html#SEC101">Examining the Symbol Table</A>.

</P>



<H2><A NAME="SEC52" HREF="gdb_toc.html#TOC52">Expressions</A></H2>

<P>
<A NAME="IDX267"></A>
<CODE>print</CODE> and many other GDB commands accept an expression and
compute its value.  Any kind of constant, variable or operator defined
by the programming language you are using is valid in an expression in
GDB.  This includes conditional expressions, function calls, casts
and string constants.  It unfortunately does not include symbols defined
by preprocessor <CODE>#define</CODE> commands.

</P>
<P>
GDB now supports array constants in expressions input by
the user.  The syntax is <VAR>{element, element...}</VAR>.  For example,
you can now use the command <CODE>print {1, 2, 3}</CODE> to build up an array in 
memory that is malloc'd in the target program.

</P>
<P>
Because C is so widespread, most of the expressions shown in examples in
this manual are in C.  See section <A HREF="gdb_10.html#SEC63">Using GDB with Different Languages</A>, for information on how to use expressions in other
languages.

</P>
<P>
In this section, we discuss operators that you can use in GDB
expressions regardless of your programming language.

</P>
<P>
Casts are supported in all languages, not just in C, because it is so
useful to cast a number into a pointer in order to examine a structure
at that address in memory.

</P>
<P>
GDB supports these operators, in addition to those common
to programming languages:

</P>
<DL COMPACT>

<DT><CODE>@</CODE>
<DD>
<SAMP>`@'</SAMP> is a binary operator for treating parts of memory as arrays.
See section <A HREF="gdb_9.html#SEC54">Artificial arrays</A>, for more information.

<DT><CODE>::</CODE>
<DD>
<SAMP>`::'</SAMP> allows you to specify a variable in terms of the file or
function where it is defined.  See section <A HREF="gdb_9.html#SEC53">Program variables</A>.

<A NAME="IDX268"></A>
<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
<A NAME="IDX271"></A>
<DT><CODE>{<VAR>type</VAR>} <VAR>addr</VAR></CODE>
<DD>
Refers to an object of type <VAR>type</VAR> stored at address <VAR>addr</VAR> in
memory.  <VAR>addr</VAR> may be any expression whose value is an integer or
pointer (but parentheses are required around binary operators, just as in
a cast).  This construct is allowed regardless of what kind of data is
normally supposed to reside at <VAR>addr</VAR>.
</DL>



<H2><A NAME="SEC53" HREF="gdb_toc.html#TOC53">Program variables</A></H2>

<P>
The most common kind of expression to use is the name of a variable
in your program.

</P>
<P>
Variables in expressions are understood in the selected stack frame
(see section <A HREF="gdb_7.html#SEC43">Selecting a frame</A>); they must be either:

</P>

<UL>
<LI>

global (or file-static)
</UL>

<P>
or 

</P>

<UL>
<LI>

visible according to the scope rules of the
programming language from the point of execution in that frame
</UL>

<P>
This means that in the function

</P>

<PRE>
foo (a)
     int a;
{
  bar (a);
  {
    int b = test ();
    bar (b);
  }
}
</PRE>

<P>
you can examine and use the variable <CODE>a</CODE> whenever your program is
executing within the function <CODE>foo</CODE>, but you can only use or
examine the variable <CODE>b</CODE> while your program is executing inside
the block where <CODE>b</CODE> is declared.

</P>
<P>
<A NAME="IDX272"></A>
There is an exception: you can refer to a variable or function whose
scope is a single source file even if the current execution point is not
in this file.  But it is possible to have more than one such variable or
function with the same name (in different source files).  If that
happens, referring to that name has unpredictable effects.  If you wish,
you can specify a static variable in a particular function or file,
using the colon-colon notation:

</P>
<P>
<A NAME="IDX273"></A>
<A NAME="IDX274"></A>

<PRE>
<VAR>file</VAR>::<VAR>variable</VAR>
<VAR>function</VAR>::<VAR>variable</VAR>
</PRE>

<P>
Here <VAR>file</VAR> or <VAR>function</VAR> is the name of the context for the
static <VAR>variable</VAR>.  In the case of file names, you can use quotes to
make sure GDB parses the file name as a single word--for example,
to print a global value of <CODE>x</CODE> defined in <TT>`f2.c'</TT>:

</P>

<PRE>
(gdb) p 'f2.c'::x
</PRE>

<P>
<A NAME="IDX275"></A>
This use of <SAMP>`::'</SAMP> is very rarely in conflict with the very similar
use of the same notation in C++.  GDB also supports use of the C++
scope resolution operator in GDB expressions.

</P>
<P>
<A NAME="IDX276"></A>
<A NAME="IDX277"></A>

<BLOCKQUOTE>
<P>
<EM>Warning:</EM> Occasionally, a local variable may appear to have the
wrong value at certain points in a function--just after entry to a new
scope, and just before exit.
</BLOCKQUOTE>

<P>
You may see this problem when you are stepping by machine instructions.
This is because, on most machines, it takes more than one instruction to
set up a stack frame (including local variable definitions); if you are
stepping by machine instructions, variables may appear to have the wrong
values until the stack frame is completely built.  On exit, it usually
also takes more than one machine instruction to destroy a stack frame;
after you begin stepping through that group of instructions, local
variable definitions may be gone.

</P>
<P>
This may also happen when the compiler does significant optimizations.
To be sure of always seeing accurate values, turn off all optimization
when compiling.

</P>


<H2><A NAME="SEC54" HREF="gdb_toc.html#TOC54">Artificial arrays</A></H2>

<P>
<A NAME="IDX278"></A>
<A NAME="IDX279"></A>
It is often useful to print out several successive objects of the
same type in memory; a section of an array, or an array of
dynamically determined size for which only a pointer exists in the
program.

</P>
<P>
You can do this by referring to a contiguous span of memory as an
<STRONG>artificial array</STRONG>, using the binary operator <SAMP>`@'</SAMP>.  The left
operand of <SAMP>`@'</SAMP> should be the first element of the desired array
and be an individual object.  The right operand should be the desired length
of the array.  The result is an array value whose elements are all of
the type of the left argument.  The first element is actually the left
argument; the second element comes from bytes of memory immediately
following those that hold the first element, and so on.  Here is an
example.  If a program says

</P>

<PRE>
int *array = (int *) malloc (len * sizeof (int));
</PRE>

<P>
you can print the contents of <CODE>array</CODE> with

</P>

<PRE>
p *array@len
</PRE>

<P>
The left operand of <SAMP>`@'</SAMP> must reside in memory.  Array values made
with <SAMP>`@'</SAMP> in this way behave just like other arrays in terms of
subscripting, and are coerced to pointers when used in expressions.
Artificial arrays most often appear in expressions via the value history
(see section <A HREF="gdb_9.html#SEC59">Value history</A>), after printing one out.

</P>
<P>
Another way to create an artificial array is to use a cast.
This re-interprets a value as if it were an array.
The value need not be in memory:

<PRE>
(gdb) p/x (short[2])0x12345678
$1 = {0x1234, 0x5678}
</PRE>

<P>
As a convenience, if you leave the array length out (as in
<SAMP>`(<VAR>type</VAR>)[])<VAR>value</VAR>'</SAMP>) gdb calculates the size to fill
the value (as <SAMP>`sizeof(<VAR>value</VAR>)/sizeof(<VAR>type</VAR>)'</SAMP>:

<PRE>
(gdb) p/x (short[])0x12345678
$2 = {0x1234, 0x5678}
</PRE>

<P>
Sometimes the artificial array mechanism is not quite enough; in
moderately complex data structures, the elements of interest may not
actually be adjacent--for example, if you are interested in the values
of pointers in an array.  One useful work-around in this situation is
to use a convenience variable (see section <A HREF="gdb_9.html#SEC60">Convenience variables</A>) as a counter in an expression that prints the first
interesting value, and then repeat that expression via <KBD>RET</KBD>.  For
instance, suppose you have an array <CODE>dtab</CODE> of pointers to
structures, and you are interested in the values of a field <CODE>fv</CODE>
in each structure.  Here is an example of what you might type:

</P>

<PRE>
set $i = 0
p dtab[$i++]-&#62;fv
<KBD>RET</KBD>
<KBD>RET</KBD>
...
</PRE>



<H2><A NAME="SEC55" HREF="gdb_toc.html#TOC55">Output formats</A></H2>

<P>
<A NAME="IDX280"></A>
<A NAME="IDX281"></A>
By default, GDB prints a value according to its data type.  Sometimes
this is not what you want.  For example, you might want to print a number
in hex, or a pointer in decimal.  Or you might want to view data in memory
at a certain address as a character string or as an instruction.  To do
these things, specify an <STRONG>output format</STRONG> when you print a value.

</P>
<P>
The simplest use of output formats is to say how to print a value
already computed.  This is done by starting the arguments of the
<CODE>print</CODE> command with a slash and a format letter.  The format
letters supported are:

</P>
<DL COMPACT>

<DT><CODE>x</CODE>
<DD>
Regard the bits of the value as an integer, and print the integer in
hexadecimal.

<DT><CODE>d</CODE>
<DD>
Print as integer in signed decimal.

<DT><CODE>u</CODE>
<DD>
Print as integer in unsigned decimal.

<DT><CODE>o</CODE>
<DD>
Print as integer in octal.

<DT><CODE>t</CODE>
<DD>
Print as integer in binary.  The letter <SAMP>`t'</SAMP> stands for "two".
<A NAME="DOCF1" HREF="gdb_foot.html#FOOT1">(1)</A>

<DT><CODE>a</CODE>
<DD>
<A NAME="IDX282"></A>
Print as an address, both absolute in hexadecimal and as an offset from
the nearest preceding symbol.  You can use this format used to discover
where (in what function) an unknown address is located:


<PRE>
(gdb) p/a 0x54320
$3 = 0x54320 &#60;_initialize_vx+396&#62;
</PRE>

<DT><CODE>c</CODE>
<DD>
Regard as an integer and print it as a character constant.

<DT><CODE>f</CODE>
<DD>
Regard the bits of the value as a floating point number and print
using typical floating point syntax.
</DL>

<P>
For example, to print the program counter in hex (see section <A HREF="gdb_9.html#SEC61">Registers</A>), type

</P>

<PRE>
p/x $pc
</PRE>

<P>
Note that no space is required before the slash; this is because command
names in GDB cannot contain a slash.

</P>
<P>
To reprint the last value in the value history with a different format,
you can use the <CODE>print</CODE> command with just a format and no
expression.  For example, <SAMP>`p/x'</SAMP> reprints the last value in hex.

</P>


<H2><A NAME="SEC56" HREF="gdb_toc.html#TOC56">Examining memory</A></H2>

<P>
You can use the command <CODE>x</CODE> (for "examine") to examine memory in
any of several formats, independently of your program's data types.

</P>
<P>
<A NAME="IDX283"></A>
<DL COMPACT>

<DT><CODE>x/<VAR>nfu</VAR> <VAR>addr</VAR></CODE>
<DD>
<A NAME="IDX284"></A>
 
<DT><CODE>x <VAR>addr</VAR></CODE>
<DD>
<DT><CODE>x</CODE>
<DD>
Use the <CODE>x</CODE> command to examine memory.
</DL>

<P>
<VAR>n</VAR>, <VAR>f</VAR>, and <VAR>u</VAR> are all optional parameters that specify how
much memory to display and how to format it; <VAR>addr</VAR> is an
expression giving the address where you want to start displaying memory.
If you use defaults for <VAR>nfu</VAR>, you need not type the slash <SAMP>`/'</SAMP>.
Several commands set convenient defaults for <VAR>addr</VAR>.

</P>
<DL COMPACT>

<DT><VAR>n</VAR>, the repeat count
<DD>
The repeat count is a decimal integer; the default is 1.  It specifies
how much memory (counting by units <VAR>u</VAR>) to display.

<DT><VAR>f</VAR>, the display format
<DD>
The display format is one of the formats used by <CODE>print</CODE>,
<SAMP>`s'</SAMP> (null-terminated string), or <SAMP>`i'</SAMP> (machine instruction).
The default is <SAMP>`x'</SAMP> (hexadecimal) initially.
The default changes each time you use either <CODE>x</CODE> or <CODE>print</CODE>.

<DT><VAR>u</VAR>, the unit size
<DD>
The unit size is any of

<DL COMPACT>

<DT><CODE>b</CODE>
<DD>
Bytes.
<DT><CODE>h</CODE>
<DD>
Halfwords (two bytes).
<DT><CODE>w</CODE>
<DD>
Words (four bytes).  This is the initial default.
<DT><CODE>g</CODE>
<DD>
Giant words (eight bytes).
</DL>

Each time you specify a unit size with <CODE>x</CODE>, that size becomes the
default unit the next time you use <CODE>x</CODE>.  (For the <SAMP>`s'</SAMP> and
<SAMP>`i'</SAMP> formats, the unit size is ignored and is normally not written.)

<DT><VAR>addr</VAR>, starting display address
<DD>
<VAR>addr</VAR> is the address where you want GDB to begin displaying
memory.  The expression need not have a pointer value (though it may);
it is always interpreted as an integer address of a byte of memory.
See section <A HREF="gdb_9.html#SEC52">Expressions</A>, for more information on expressions.  The default for
<VAR>addr</VAR> is usually just after the last address examined--but several
other commands also set the default address: <CODE>info breakpoints</CODE> (to
the address of the last breakpoint listed), <CODE>info line</CODE> (to the
starting address of a line), and <CODE>print</CODE> (if you use it to display
a value from memory).
</DL>

<P>
For example, <SAMP>`x/3uh 0x54320'</SAMP> is a request to display three halfwords
(<CODE>h</CODE>) of memory, formatted as unsigned decimal integers (<SAMP>`u'</SAMP>),
starting at address <CODE>0x54320</CODE>.  <SAMP>`x/4xw $sp'</SAMP> prints the four
words (<SAMP>`w'</SAMP>) of memory above the stack pointer (here, <SAMP>`$sp'</SAMP>;
see section <A HREF="gdb_9.html#SEC61">Registers</A>) in hexadecimal (<SAMP>`x'</SAMP>).

</P>
<P>
Since the letters indicating unit sizes are all distinct from the
letters specifying output formats, you do not have to remember whether
unit size or format comes first; either order works.  The output
specifications <SAMP>`4xw'</SAMP> and <SAMP>`4wx'</SAMP> mean exactly the same thing.
(However, the count <VAR>n</VAR> must come first; <SAMP>`wx4'</SAMP> does not work.)

</P>
<P>
Even though the unit size <VAR>u</VAR> is ignored for the formats <SAMP>`s'</SAMP>
and <SAMP>`i'</SAMP>, you might still want to use a count <VAR>n</VAR>; for example,
<SAMP>`3i'</SAMP> specifies that you want to see three machine instructions,
including any operands.  The command <CODE>disassemble</CODE> gives an
alternative way of inspecting machine instructions; see section <A HREF="gdb_8.html#SEC50">Source and machine code</A>.

</P>
<P>
All the defaults for the arguments to <CODE>x</CODE> are designed to make it
easy to continue scanning memory with minimal specifications each time
you use <CODE>x</CODE>.  For example, after you have inspected three machine
instructions with <SAMP>`x/3i <VAR>addr</VAR>'</SAMP>, you can inspect the next seven
with just <SAMP>`x/7'</SAMP>.  If you use <KBD>RET</KBD> to repeat the <CODE>x</CODE> command,
the repeat count <VAR>n</VAR> is used again; the other arguments default as
for successive uses of <CODE>x</CODE>.

</P>
<P>
<A NAME="IDX285"></A>
The addresses and contents printed by the <CODE>x</CODE> command are not saved
in the value history because there is often too much of them and they
would get in the way.  Instead, GDB makes these values available for
subsequent use in expressions as values of the convenience variables
<CODE>$_</CODE> and <CODE>$__</CODE>.  After an <CODE>x</CODE> command, the last address
examined is available for use in expressions in the convenience variable
<CODE>$_</CODE>.  The contents of that address, as examined, are available in
the convenience variable <CODE>$__</CODE>.

</P>
<P>
If the <CODE>x</CODE> command has a repeat count, the address and contents saved
are from the last memory unit printed; this is not the same as the last
address printed if several units were printed on the last line of output.

</P>


<H2><A NAME="SEC57" HREF="gdb_toc.html#TOC57">Automatic display</A></H2>
<P>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>

</P>
<P>
If you find that you want to print the value of an expression frequently
(to see how it changes), you might want to add it to the <STRONG>automatic
display list</STRONG> so that GDB prints its value each time your program stops.
Each expression added to the list is given a number to identify it;
to remove an expression from the list, you specify that number.
The automatic display looks like this:

</P>

<PRE>
2: foo = 38
3: bar[5] = (struct hack *) 0x3804
</PRE>

<P>
This display shows item numbers, expressions and their current values.  As with
displays you request manually using <CODE>x</CODE> or <CODE>print</CODE>, you can
specify the output format you prefer; in fact, <CODE>display</CODE> decides
whether to use <CODE>print</CODE> or <CODE>x</CODE> depending on how elaborate your
format specification is--it uses <CODE>x</CODE> if you specify a unit size,
or one of the two formats (<SAMP>`i'</SAMP> and <SAMP>`s'</SAMP>) that are only
supported by <CODE>x</CODE>; otherwise it uses <CODE>print</CODE>.

</P>
<DL COMPACT>

<DT><CODE>display <VAR>exp</VAR></CODE>
<DD>
<A NAME="IDX288"></A>
 
Add the expression <VAR>exp</VAR> to the list of expressions to display
each time your program stops.  See section <A HREF="gdb_9.html#SEC52">Expressions</A>.

<CODE>display</CODE> does not repeat if you press <KBD>RET</KBD> again after using it.

<DT><CODE>display/<VAR>fmt</VAR> <VAR>exp</VAR></CODE>
<DD>
For <VAR>fmt</VAR> specifying only a display format and not a size or
count, add the expression <VAR>exp</VAR> to the auto-display list but
arrange to display it each time in the specified format <VAR>fmt</VAR>.
See section <A HREF="gdb_9.html#SEC55">Output formats</A>.

<DT><CODE>display/<VAR>fmt</VAR> <VAR>addr</VAR></CODE>
<DD>
For <VAR>fmt</VAR> <SAMP>`i'</SAMP> or <SAMP>`s'</SAMP>, or including a unit-size or a
number of units, add the expression <VAR>addr</VAR> as a memory address to
be examined each time your program stops.  Examining means in effect
doing <SAMP>`x/<VAR>fmt</VAR> <VAR>addr</VAR>'</SAMP>.  See section <A HREF="gdb_9.html#SEC56">Examining memory</A>.
</DL>

<P>
For example, <SAMP>`display/i $pc'</SAMP> can be helpful, to see the machine
instruction about to be executed each time execution stops (<SAMP>`$pc'</SAMP>
is a common name for the program counter; see section <A HREF="gdb_9.html#SEC61">Registers</A>).

</P>
<DL COMPACT>

<DT><CODE>undisplay <VAR>dnums</VAR>...</CODE>
<DD>
<A NAME="IDX289"></A>
 <A NAME="IDX290"></A>
 
<DT><CODE>delete display <VAR>dnums</VAR>...</CODE>
<DD>
Remove item numbers <VAR>dnums</VAR> from the list of expressions to display.

<CODE>undisplay</CODE> does not repeat if you press <KBD>RET</KBD> after using it.
(Otherwise you would just get the error <SAMP>`No display number ...'</SAMP>.)

<A NAME="IDX291"></A>
<DT><CODE>disable display <VAR>dnums</VAR>...</CODE>
<DD>
Disable the display of item numbers <VAR>dnums</VAR>.  A disabled display
item is not printed automatically, but is not forgotten.  It may be
enabled again later.

<A NAME="IDX292"></A>
<DT><CODE>enable display <VAR>dnums</VAR>...</CODE>
<DD>
Enable display of item numbers <VAR>dnums</VAR>.  It becomes effective once
again in auto display of its expression, until you specify otherwise.

<DT><CODE>display</CODE>
<DD>
Display the current values of the expressions on the list, just as is
done when your program stops.

<A NAME="IDX293"></A>
<DT><CODE>info display</CODE>
<DD>
Print the list of expressions previously set up to display
automatically, each one with its item number, but without showing the
values.  This includes disabled expressions, which are marked as such.
It also includes expressions which would not be displayed right now
because they refer to automatic variables not currently available.
</DL>

<P>
If a display expression refers to local variables, then it does not make
sense outside the lexical context for which it was set up.  Such an
expression is disabled when execution enters a context where one of its
variables is not defined.  For example, if you give the command
<CODE>display last_char</CODE> while inside a function with an argument
<CODE>last_char</CODE>, GDB displays this argument while your program
continues to stop inside that function.  When it stops elsewhere--where
there is no variable <CODE>last_char</CODE>---the display is disabled
automatically.  The next time your program stops where <CODE>last_char</CODE>
is meaningful, you can enable the display expression once again.

</P>


<H2><A NAME="SEC58" HREF="gdb_toc.html#TOC58">Print settings</A></H2>

<P>
<A NAME="IDX294"></A>
<A NAME="IDX295"></A>
GDB provides the following ways to control how arrays, structures,
and symbols are printed.

</P>
<P>
These settings are useful for debugging programs in any language:

</P>
<DL COMPACT>

<DT><CODE>set print address</CODE>
<DD>
<A NAME="IDX296"></A>
 
<DT><CODE>set print address on</CODE>
<DD>
GDB prints memory addresses showing the location of stack
traces, structure values, pointer values, breakpoints, and so forth,
even when it also displays the contents of those addresses.  The default
is <CODE>on</CODE>.  For example, this is what a stack frame display looks like with
<CODE>set print address on</CODE>:


<PRE>
(gdb) f
#0  set_quotes (lq=0x34c78 "&#60;&#60;", rq=0x34c88 "&#62;&#62;")
    at input.c:530
530         if (lquote != def_lquote)
</PRE>

<DT><CODE>set print address off</CODE>
<DD>
Do not print addresses when displaying their contents.  For example,
this is the same stack frame displayed with <CODE>set print address off</CODE>:


<PRE>
(gdb) set print addr off
(gdb) f
#0  set_quotes (lq="&#60;&#60;", rq="&#62;&#62;") at input.c:530
530         if (lquote != def_lquote)
</PRE>

You can use <SAMP>`set print address off'</SAMP> to eliminate all machine
dependent displays from the GDB interface.  For example, with
<CODE>print address off</CODE>, you should get the same text for backtraces on
all machines--whether or not they involve pointer arguments.

<A NAME="IDX297"></A>
<DT><CODE>show print address</CODE>
<DD>
Show whether or not addresses are to be printed.
</DL>

<P>
When GDB prints a symbolic address, it normally prints the
closest earlier symbol plus an offset.  If that symbol does not uniquely
identify the address (for example, it is a name whose scope is a single
source file), you may need to clarify.  One way to do this is with
<CODE>info line</CODE>, for example <SAMP>`info line *0x4537'</SAMP>.  Alternately,
you can set GDB to print the source file and line number when
it prints a symbolic address:

</P>
<DL COMPACT>

<DT><CODE>set print symbol-filename on</CODE>
<DD>
<A NAME="IDX298"></A>
 
Tell GDB to print the source file name and line number of a
symbol in the symbolic form of an address.

<DT><CODE>set print symbol-filename off</CODE>
<DD>
Do not print source file name and line number of a symbol.  This is the
default.

<A NAME="IDX299"></A>
<DT><CODE>show print symbol-filename</CODE>
<DD>
Show whether or not GDB will print the source file name and
line number of a symbol in the symbolic form of an address.
</DL>

<P>
Another situation where it is helpful to show symbol filenames and line
numbers is when disassembling code; GDB shows you the line
number and source file that corresponds to each instruction.

</P>
<P>
Also, you may wish to see the symbolic form only if the address being
printed is reasonably close to the closest earlier symbol:

</P>
<DL COMPACT>

<DT><CODE>set print max-symbolic-offset <VAR>max-offset</VAR></CODE>
<DD>
<A NAME="IDX300"></A>
 
Tell GDB to only display the symbolic form of an address if the
offset between the closest earlier symbol and the address is less than
<VAR>max-offset</VAR>.  The default is 0, which tells GDB 
to always print the symbolic form of an address if any symbol precedes it.

<A NAME="IDX301"></A>
<DT><CODE>show print max-symbolic-offset</CODE>
<DD>
Ask how large the maximum offset is that GDB prints in a
symbolic address.
</DL>

<P>
<A NAME="IDX302"></A>
<A NAME="IDX303"></A>
If you have a pointer and you are not sure where it points, try
<SAMP>`set print symbol-filename on'</SAMP>.  Then you can determine the name
and source file location of the variable where it points, using
<SAMP>`p/a <VAR>pointer</VAR>'</SAMP>.  This interprets the address in symbolic form.
For example, here GDB shows that a variable <CODE>ptt</CODE> points
at another variable <CODE>t</CODE>, defined in <TT>`hi2.c'</TT>:

</P>

<PRE>
(gdb) set print symbol-filename on
(gdb) p/a ptt
$4 = 0xe008 &#60;t in hi2.c&#62;
</PRE>


<BLOCKQUOTE>
<P>
<EM>Warning:</EM> For pointers that point to a local variable, <SAMP>`p/a'</SAMP>
does not show the symbol name and filename of the referent, even with
the appropriate <CODE>set print</CODE> options turned on.
</BLOCKQUOTE>

<P>
Other settings control how different kinds of objects are printed:

</P>
<DL COMPACT>

<DT><CODE>set print array</CODE>
<DD>
<A NAME="IDX304"></A>
 
<DT><CODE>set print array on</CODE>
<DD>
Pretty print arrays.  This format is more convenient to read,
but uses more space.  The default is off.

<DT><CODE>set print array off</CODE>
<DD>
Return to compressed format for arrays.

<A NAME="IDX305"></A>
<DT><CODE>show print array</CODE>
<DD>
Show whether compressed or pretty format is selected for displaying
arrays.

<A NAME="IDX306"></A>
<DT><CODE>set print elements <VAR>number-of-elements</VAR></CODE>
<DD>
Set a limit on how many elements of an array GDB will print.
If GDB is printing a large array, it stops printing after it has
printed the number of elements set by the <CODE>set print elements</CODE> command.
This limit also applies to the display of strings.
Setting  <VAR>number-of-elements</VAR> to zero means that the printing is unlimited.

<A NAME="IDX307"></A>
<DT><CODE>show print elements</CODE>
<DD>
Display the number of elements of a large array that GDB will print.
If the number is 0, then the printing is unlimited.

<A NAME="IDX308"></A>
<DT><CODE>set print null-stop</CODE>
<DD>
Cause GDB to stop printing the characters of an array when the first
NULL is encountered.  This is useful when large arrays actually
contain only short strings.

<A NAME="IDX309"></A>
<DT><CODE>set print pretty on</CODE>
<DD>
Cause GDB to print structures in an indented format with one member 
per line, like this:


<PRE>
$1 = {
  next = 0x0,
  flags = {
    sweet = 1,
    sour = 1
  },
  meat = 0x54 "Pork"
}
</PRE>

<DT><CODE>set print pretty off</CODE>
<DD>
Cause GDB to print structures in a compact format, like this:


<PRE>
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
meat = 0x54 "Pork"}
</PRE>

This is the default format.

<A NAME="IDX310"></A>
<DT><CODE>show print pretty</CODE>
<DD>
Show which format GDB is using to print structures.

<A NAME="IDX311"></A>
<DT><CODE>set print sevenbit-strings on</CODE>
<DD>
Print using only seven-bit characters; if this option is set,
GDB displays any eight-bit characters (in strings or
character values) using the notation <CODE>\</CODE><VAR>nnn</VAR>.  This setting is
best if you are working in English (ASCII) and you use the
high-order bit of characters as a marker or "meta" bit.

<DT><CODE>set print sevenbit-strings off</CODE>
<DD>
Print full eight-bit characters.  This allows the use of more
international character sets, and is the default.

<A NAME="IDX312"></A>
<DT><CODE>show print sevenbit-strings</CODE>
<DD>
Show whether or not GDB is printing only seven-bit characters.

<A NAME="IDX313"></A>
<DT><CODE>set print union on</CODE>
<DD>
Tell GDB to print unions which are contained in structures.  This 
is the default setting.

<DT><CODE>set print union off</CODE>
<DD>
Tell GDB not to print unions which are contained in structures.

<A NAME="IDX314"></A>
<DT><CODE>show print union</CODE>
<DD>
Ask GDB whether or not it will print unions which are contained in
structures.

For example, given the declarations


<PRE>
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly} 
              Bug_forms;

struct thing {
  Species it;
  union {
    Tree_forms tree;
    Bug_forms bug;
  } form;
};

struct thing foo = {Tree, {Acorn}};
</PRE>

with <CODE>set print union on</CODE> in effect <SAMP>`p foo'</SAMP> would print


<PRE>
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
</PRE>

and with <CODE>set print union off</CODE> in effect it would print


<PRE>
$1 = {it = Tree, form = {...}}
</PRE>

</DL>

<P>
These settings are of interest when debugging C++ programs:

</P>
<DL COMPACT>

<DT><CODE>set print demangle</CODE>
<DD>
<A NAME="IDX315"></A>
 <A NAME="IDX316"></A>
 
<DT><CODE>set print demangle on</CODE>
<DD>
Print C++ names in their source form rather than in the encoded
("mangled") form passed to the assembler and linker for type-safe
linkage.  The default is <SAMP>`on'</SAMP>.

<A NAME="IDX317"></A>
<DT><CODE>show print demangle</CODE>
<DD>
Show whether C++ names are printed in mangled or demangled form.

<A NAME="IDX318"></A>
<DT><CODE>set print asm-demangle</CODE>
<DD>
<DT><CODE>set print asm-demangle on</CODE>
<DD>
Print C++ names in their source form rather than their mangled form, even
in assembler code printouts such as instruction disassemblies.
The default is off.

<A NAME="IDX319"></A>
<DT><CODE>show print asm-demangle</CODE>
<DD>
Show whether C++ names in assembly listings are printed in mangled
or demangled form.

<A NAME="IDX320"></A>
<A NAME="IDX321"></A>
<A NAME="IDX322"></A>
<DT><CODE>set demangle-style <VAR>style</VAR></CODE>
<DD>
Choose among several encoding schemes used by different compilers to
represent C++ names.  The choices for <VAR>style</VAR> are currently:

<DL COMPACT>

<DT><CODE>auto</CODE>
<DD>
Allow GDB to choose a decoding style by inspecting your program.

<DT><CODE>gnu</CODE>
<DD>
Decode based on the GNU C++ compiler (<CODE>g++</CODE>) encoding algorithm.  
This is the default.

<DT><CODE>hp</CODE>
<DD>
Decode based on the HP ANSI C++ (<CODE>aCC</CODE>) encoding algorithm.

<DT><CODE>lucid</CODE>
<DD>
Decode based on the Lucid C++ compiler (<CODE>lcc</CODE>) encoding algorithm.

<DT><CODE>arm</CODE>
<DD>
Decode using the algorithm in the <CITE>C++ Annotated Reference Manual</CITE>.
<STRONG>Warning:</STRONG> this setting alone is not sufficient to allow
debugging <CODE>cfront</CODE>-generated executables.  GDB would
require further enhancement to permit that.

</DL>
If you omit <VAR>style</VAR>, you will see a list of possible formats.

<A NAME="IDX323"></A>
<DT><CODE>show demangle-style</CODE>
<DD>
Display the encoding style currently in use for decoding C++ symbols.

<A NAME="IDX324"></A>
<DT><CODE>set print object</CODE>
<DD>
<DT><CODE>set print object on</CODE>
<DD>
When displaying a pointer to an object, identify the <EM>actual</EM>
(derived) type of the object rather than the <EM>declared</EM> type, using
the virtual function table.

<DT><CODE>set print object off</CODE>
<DD>
Display only the declared type of objects, without reference to the
virtual function table.  This is the default setting.

<A NAME="IDX325"></A>
<DT><CODE>show print object</CODE>
<DD>
Show whether actual, or declared, object types are displayed.

<A NAME="IDX326"></A>
<DT><CODE>set print static-members</CODE>
<DD>
<DT><CODE>set print static-members on</CODE>
<DD>
Print static members when displaying a C++ object.  The default is on.

<DT><CODE>set print static-members off</CODE>
<DD>
Do not print static members when displaying a C++ object.

<A NAME="IDX327"></A>
<DT><CODE>show print static-members</CODE>
<DD>
Show whether C++ static members are printed, or not.

<A NAME="IDX328"></A>
<DT><CODE>set print vtbl</CODE>
<DD>
<DT><CODE>set print vtbl on</CODE>
<DD>
Pretty print C++ virtual function tables.  The default is off.

<DT><CODE>set print vtbl off</CODE>
<DD>
Do not pretty print C++ virtual function tables.

<A NAME="IDX329"></A>
<DT><CODE>show print vtbl</CODE>
<DD>
Show whether C++ virtual function tables are pretty printed, or not.
</DL>



<H2><A NAME="SEC59" HREF="gdb_toc.html#TOC59">Value history</A></H2>

<P>
<A NAME="IDX330"></A>
Values printed by the <CODE>print</CODE> command are saved in the GDB 
<STRONG>value history</STRONG>.  This allows you to refer to them in other expressions.  
Values are kept until the symbol table is re-read or discarded 
(for example with the <CODE>file</CODE> or <CODE>symbol-file</CODE> commands).  
When the symbol table changes, the value history is discarded, 
since the values may contain pointers back to the types defined in the 
symbol table.

</P>
<P>
<A NAME="IDX331"></A>
<A NAME="IDX332"></A>
<A NAME="IDX333"></A>
The values printed are given <STRONG>history numbers</STRONG> by which you can
refer to them.  These are successive integers starting with one.
<CODE>print</CODE> shows you the history number assigned to a value by
printing <SAMP>`$<VAR>num</VAR> = '</SAMP> before the value; here <VAR>num</VAR> is the
history number.

</P>
<P>
To refer to any previous value, use <SAMP>`$'</SAMP> followed by the value's
history number.  The way <CODE>print</CODE> labels its output is designed to
remind you of this.  Just <CODE>$</CODE> refers to the most recent value in
the history, and <CODE>$$</CODE> refers to the value before that.
<CODE>$$<VAR>n</VAR></CODE> refers to the <VAR>n</VAR>th value from the end; <CODE>$$2</CODE>
is the value just prior to <CODE>$$</CODE>, <CODE>$$1</CODE> is equivalent to
<CODE>$$</CODE>, and <CODE>$$0</CODE> is equivalent to <CODE>$</CODE>.

</P>
<P>
For example, suppose you have just printed a pointer to a structure and
want to see the contents of the structure.  It suffices to type

</P>

<PRE>
p *$
</PRE>

<P>
If you have a chain of structures where the component <CODE>next</CODE> points
to the next one, you can print the contents of the next one with this:

</P>

<PRE>
p *$.next
</PRE>

<P>
You can print successive links in the chain by repeating this
command--which you can do by just typing <KBD>RET</KBD>.

</P>
<P>
Note that the history records values, not expressions.  If the value of
<CODE>x</CODE> is 4 and you type these commands:

</P>

<PRE>
print x
set x=5
</PRE>

<P>
then the value recorded in the value history by the <CODE>print</CODE> command
remains 4 even though the value of <CODE>x</CODE> has changed.

</P>
<DL COMPACT>

<DT><CODE>show values</CODE>
<DD>
<A NAME="IDX334"></A>
 
Print the last ten values in the value history, with their item numbers.
This is like <SAMP>`p $$9'</SAMP> repeated ten times, except that <CODE>show
values</CODE> does not change the history.

<DT><CODE>show values <VAR>n</VAR></CODE>
<DD>
Print ten history values centered on history item number <VAR>n</VAR>.

<DT><CODE>show values +</CODE>
<DD>
Print ten history values just after the values last printed.  If no more
values are available, <CODE>show values +</CODE> produces no display.
</DL>

<P>
Pressing <KBD>RET</KBD> to repeat <CODE>show values <VAR>n</VAR></CODE> has exactly the
same effect as <SAMP>`show values +'</SAMP>.

</P>


<H2><A NAME="SEC60" HREF="gdb_toc.html#TOC60">Convenience variables</A></H2>

<P>
<A NAME="IDX335"></A>
GDB provides <STRONG>convenience variables</STRONG> that you can use within
GDB to hold on to a value and refer to it later.  These variables
exist entirely within GDB; they are not part of your program, and
setting a convenience variable has no direct effect on further execution
of your program.  That is why you can use them freely.

</P>
<P>
Convenience variables are prefixed with <SAMP>`$'</SAMP>.  Any name preceded by
<SAMP>`$'</SAMP> can be used for a convenience variable, unless it is one of
the predefined machine-specific register names (see section <A HREF="gdb_9.html#SEC61">Registers</A>).
(Value history references, in contrast, are <EM>numbers</EM> preceded
by <SAMP>`$'</SAMP>.  See section <A HREF="gdb_9.html#SEC59">Value history</A>.)

</P>
<P>
You can save a value in a convenience variable with an assignment
expression, just as you would set a variable in your program.
For example:

</P>

<PRE>
set $foo = *object_ptr
</PRE>

<P>
would save in <CODE>$foo</CODE> the value contained in the object pointed to by
<CODE>object_ptr</CODE>.

</P>
<P>
Using a convenience variable for the first time creates it, but its
value is <CODE>void</CODE> until you assign a new value.  You can alter the
value with another assignment at any time.

</P>
<P>
Convenience variables have no fixed types.  You can assign a convenience
variable any type of value, including structures and arrays, even if
that variable already has a value of a different type.  The convenience
variable, when used as an expression, has the type of its current value.

</P>
<DL COMPACT>

<DT><CODE>show convenience</CODE>
<DD>
<A NAME="IDX336"></A>
 
Print a list of convenience variables used so far, and their values.
Abbreviated <CODE>show con</CODE>.
</DL>

<P>
One of the ways to use a convenience variable is as a counter to be
incremented or a pointer to be advanced.  For example, to print
a field from successive elements of an array of structures:

</P>

<PRE>
set $i = 0
print bar[$i++]-&#62;contents
</PRE>

<P>
Repeat that command by typing <KBD>RET</KBD>.

</P>
<P>
Some convenience variables are created automatically by GDB and given
values likely to be useful.

</P>
<DL COMPACT>

<DT><CODE>$_</CODE>
<DD>
<A NAME="IDX337"></A>
 
The variable <CODE>$_</CODE> is automatically set by the <CODE>x</CODE> command to
the last address examined (see section <A HREF="gdb_9.html#SEC56">Examining memory</A>).  Other
commands which provide a default address for <CODE>x</CODE> to examine also
set <CODE>$_</CODE> to that address; these commands include <CODE>info line</CODE>
and <CODE>info breakpoint</CODE>.  The type of <CODE>$_</CODE> is <CODE>void *</CODE>
except when set by the <CODE>x</CODE> command, in which case it is a pointer
to the type of <CODE>$__</CODE>.

<A NAME="IDX338"></A>
<DT><CODE>$__</CODE>
<DD>
The variable <CODE>$__</CODE> is automatically set by the <CODE>x</CODE> command
to the value found in the last address examined.  Its type is chosen
to match the format in which the data was printed.

<DT><CODE>$_exitcode</CODE>
<DD>
<A NAME="IDX339"></A>
The variable <CODE>$_exitcode</CODE> is automatically set to the exit code when
the program being debugged terminates.
</DL>



<H2><A NAME="SEC61" HREF="gdb_toc.html#TOC61">Registers</A></H2>

<P>
<A NAME="IDX340"></A>
You can refer to machine register contents, in expressions, as variables
with names starting with <SAMP>`$'</SAMP>.  The names of registers are different
for each machine; use <CODE>info registers</CODE> to see the names used on
your machine.

</P>
<DL COMPACT>

<DT><CODE>info registers</CODE>
<DD>
<A NAME="IDX341"></A>
 
Print the names and values of all registers except floating-point
registers (in the selected stack frame).

<A NAME="IDX342"></A>
<A NAME="IDX343"></A>
<DT><CODE>info all-registers</CODE>
<DD>
Print the names and values of all registers, including floating-point
registers.

<DT><CODE>info registers <VAR>regname</VAR> ...</CODE>
<DD>
Print the <STRONG>relativized</STRONG> value of each specified register <VAR>regname</VAR>.
As discussed in detail below, register values are normally relative to 
the selected stack frame.  <VAR>regname</VAR> may be any register name valid on 
the machine you are using, with or without the initial <SAMP>`$'</SAMP>.
</DL>

<P>
GDB has four "standard" register names that are available (in
expressions) on most machines--whenever they do not conflict with an
architecture's canonical mnemonics for registers.  The register names
<CODE>$pc</CODE> and <CODE>$sp</CODE> are used for the program counter register and
the stack pointer.  <CODE>$fp</CODE> is used for a register that contains a
pointer to the current stack frame, and <CODE>$ps</CODE> is used for a
register that contains the processor status.  For example,
you could print the program counter in hex with

</P>

<PRE>
p/x $pc
</PRE>

<P>
or print the instruction to be executed next with

</P>

<PRE>
x/i $pc
</PRE>

<P>
or add four to the stack pointer<A NAME="DOCF2" HREF="gdb_foot.html#FOOT2">(2)</A> with

</P>

<PRE>
set $sp += 4
</PRE>

<P>
Whenever possible, these four standard register names are available on
your machine even though the machine has different canonical mnemonics,
so long as there is no conflict.  The <CODE>info registers</CODE> command
shows the canonical names.  For example, on the SPARC, <CODE>info
registers</CODE> displays the processor status register as <CODE>$psr</CODE> but you
can also refer to it as <CODE>$ps</CODE>.

</P>
<P>
GDB always considers the contents of an ordinary register as an
integer when the register is examined in this way.  Some machines have
special registers which can hold nothing but floating point; these
registers are considered to have floating point values.  There is no way
to refer to the contents of an ordinary register as floating point value
(although you can <EM>print</EM> it as a floating point value with
<SAMP>`print/f $<VAR>regname</VAR>'</SAMP>).

</P>
<P>
Some registers have distinct "raw" and "virtual" data formats.  This
means that the data format in which the register contents are saved by
the operating system is not the same one that your program normally
sees.  For example, the registers of the 68881 floating point
coprocessor are always saved in "extended" (raw) format, but all C
programs expect to work with "double" (virtual) format.  In such
cases, GDB normally works with the virtual format only (the format 
that makes sense for your program), but the <CODE>info registers</CODE> command
prints the data in both formats.

</P>
<P>
Normally, register values are relative to the selected stack frame
(see section <A HREF="gdb_7.html#SEC43">Selecting a frame</A>).  This means that you get the
value that the register would contain if all stack frames farther in
were exited and their saved registers restored.  In order to see the
true contents of hardware registers, you must select the innermost
frame (with <SAMP>`frame 0'</SAMP>).

</P>
<P>
However, GDB must deduce where registers are saved, from the machine
code generated by your compiler.  If some registers are not saved, or if
GDB is unable to locate the saved registers, the selected stack
frame makes no difference.

</P>
<DL COMPACT>

<DT><CODE>set rstack_high_address <VAR>address</VAR></CODE>
<DD>
<A NAME="IDX344"></A>
 <A NAME="IDX345"></A>
 <A NAME="IDX346"></A>
 
On AMD 29000 family processors, registers are saved in a separate
"register stack".  There is no way for GDB to determine the extent
of this stack.  Normally, GDB just assumes that the stack is "large
enough".  This may result in GDB referencing memory locations that
do not exist.  If necessary, you can get around this problem by
specifying the ending address of the register stack with the <CODE>set
rstack_high_address</CODE> command.  The argument should be an address, which
you probably want to precede with <SAMP>`0x'</SAMP> to specify in
hexadecimal.

<A NAME="IDX347"></A>
<DT><CODE>show rstack_high_address</CODE>
<DD>
Display the current limit of the register stack, on AMD 29000 family
processors.
</DL>



<H2><A NAME="SEC62" HREF="gdb_toc.html#TOC62">Floating point hardware</A></H2>
<P>
<A NAME="IDX348"></A>

</P>
<P>
Depending on the configuration, GDB may be able to give
you more information about the status of the floating point hardware.

</P>
<DL COMPACT>

<DT><CODE>info float</CODE>
<DD>
<A NAME="IDX349"></A>
 
Display hardware-dependent information about the floating
point unit.  The exact contents and layout vary depending on the
floating point chip.  Currently, <SAMP>`info float'</SAMP> is supported on
the ARM and x86 machines.
</DL>

<P><HR><P>
Go to the <A HREF="gdb_1.html">first</A>, <A HREF="gdb_8.html">previous</A>, <A HREF="gdb_10.html">next</A>, <A HREF="gdb_21.html">last</A> section, <A HREF="gdb_toc.html">table of contents</A>.
</BODY>
</HTML>
